---
title: 数据库实现八基于内存的存储引擎
date: 2024-10-19 11:29:11
tags: 数据库
categories: rust，数据库
---
## 内存存储引擎
这一小节我们来实现一个基于内存的存储引擎。由于这个存储引擎是使用内存来实现存储，所以不具备持久化的功能，一旦程序退出，那么数据都将消失。但是通过直接对内存的读取和写入，效率则相比于磁盘会高。后续会实现基于物理磁盘的存储。

### 定义
```rust
pub struct MemoryEngine {
    data: BTreeMap<Vec<u8>,Vec<u8>>,
}
```
这里我们直接使用了 rust 自带的 BTreeMap 结构来实现内存中数据的存储。BTreeMap 已经实现了很多可用的操作，非常方便。

接下来为内存引擎实现我们定义的 trait。
```rust
impl super::engine::Engine for MemoryEngine {
    type EngineIterator<'a> = MemoryEngineIterator<'a>;

    fn set(&mut self, key: Vec<u8>, value: Vec<u8>) -> Result<()> {
        self.data.insert(key, value);
        Ok(())
    }

    fn get(&mut self, key: Vec<u8>) -> Result<Option<Vec<u8>>> {
        let val = self.data.get(&key).cloned();
        Ok(val)
    }

    fn delete(&mut self, key: Vec<u8>) -> Result<()> {
        self.data.remove(&key);
        Ok(())
    }

    fn scan(&mut self, range: impl std::ops::RangeBounds<Vec<u8>>) -> Self::EngineIterator<'_> {
        MemoryEngineIterator {
            inner: self.data.range(range)
        }
    }
}
```
这里我们都是直接调用 BTreeMap 的接口进行操作，但我们还需要为它实现一个迭代器类型，当进行区间扫描时，我们会返回一个迭代器，其中包含扫描到的内容。
```rust
pub struct MemoryEngineIterator<'a> {
    inner: btree_map::Range<'a, Vec<u8>,Vec<u8>>,
}

impl<'a> MemoryEngineIterator<'a> {
    fn map(item: (&Vec<u8>,&Vec<u8>)) -> <Self as Iterator>::Item{
        let (key,val) = item;
        Ok((key.clone(),val.clone()))
    }
}

impl<'a> Iterator for MemoryEngineIterator<'a> {
    type Item = Result<(Vec<u8>,Vec<u8>)>;

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next().map(Self::map)
    }
}

impl<'a> DoubleEndedIterator for MemoryEngineIterator<'a> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.inner.next_back().map(Self::map)
    }
}
```
这里内部我们使用 btree_map::Range ，这是一个包含了一个指定范围的迭代器。它可以通过 range() 方法来创建。然后我们给这个迭代器类型实现 next 方法之后，即可迭代这个范围。同时这个类型还需要实现双端队列的接口，因为我们在 trait 定义时做了这个约束。这个由于 BTreeMap 也实现了双端队列接口，因此我们直接使用 BTreeMap 的方法即可。

这样一个有基本功能的内存引擎就实现完成了，但是还有一点需要注意，我们的底层的存储引擎接口的参数均为 u8 类型的数组，也就是说我们需要将文本等内容进行一个序列化，然后才能调用相应的接口，这个序列化的操作我们会放在 sql引擎层，而且我们还会在 sql引擎层对传入的内容进行类型的判断等逻辑操作，最后确认无误之后，将数据序列化，调用存储引擎去存储。下一节，我们就对 sql引擎层进行一个完善。