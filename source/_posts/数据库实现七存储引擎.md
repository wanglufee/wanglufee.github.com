---
title: 数据库实现七存储引擎
date: 2024-10-02 09:22:29
tags: 数据库
categories: rust，数据库
---
## 存储引擎
存储引擎层是我们真正和数据打交道的地方，这里会真正的执行对数据的存储，更新，读取等操作，上一节的sql 引擎其实也就是对存储引擎的一个封装，这样使用起来会更加灵活。

存储引擎的定义：
```rust
pub trait Engine {
    
    type EngineIterator<'a> : EngineIterator where Self: 'a;

    // 设置 key/value
    fn set(&mut self, key: Vec<u8>, value: Vec<u8>) -> Result<()>;

    // 获取 key 对应的 value
    fn get(&mut self, key: Vec<u8>) -> Result<Option<Vec<u8>>>;

    // 删除 key 对应数据，如果 key 不存在则忽略
    fn delete(&mut self, key: Vec<u8>) -> Result<()>;

    // 扫描
    fn scan(&mut self, range: impl RangeBounds<Vec<u8>>) -> Self::EngineIterator<'_>;

    // 前缀扫描
    fn scan_prefix(&mut self, prefix: Vec<u8>) -> Self::EngineIterator<'_>{
        let start = Bound::Included(prefix.clone());
        let mut bound_prefix = prefix.clone();
        if let Some(last) = bound_prefix.iter_mut().last() {
            *last += 1;
        }
        let end = Bound::Excluded(bound_prefix);
        self.scan((start,end))
    }
}
```
这里主要包含了存储，获取，删除，扫描四个操作，其中的前缀扫描是通过拿到前缀（被转换成 u8 数组），然后通过将前缀数组的最后一个元素加一，即可得到需要扫描的终止点，然后扫描以前缀开始，到终止的所有数据。

这里的扫描方法会返回一个迭代器类型，通过返回的迭代器类型可以去遍历区间中包含哪些元素。
```rust
pub trait EngineIterator: DoubleEndedIterator<Item = Result<(Vec<u8>,Vec<u8>)>> {
    
}
```
我们希望这个迭代器类型可以实现双端队列的 trait。

后续我们会实现不同的存储引擎，他们只需要实现这个 trait 中的操作即可。
## mvcc事务
我们的每个数据操作都是在事务中进行，当执行完成之后提交事务，如果执行失败则回滚事务，sql 引擎层的事务同样是对底层 mvcc事务的封装，mvcc事务会实现其中具体的操作。

mvcc定义：
```rust
pub struct Mvcc<E : Engine>{
    engine: Arc<Mutex<E>>,
}

impl<E : Engine> Clone for Mvcc<E> {
    fn clone(&self) -> Self {
        Self { engine: self.engine.clone() }
    }
}

impl<E : Engine> Mvcc<E> {
    pub fn new(eng: E) -> Self {
        Self { engine:Arc::new(Mutex::new(eng)) }
    }

    pub fn begin(&self) -> Result<MvccTransaction<E>> {
        Ok(MvccTransaction::begin(self.engine.clone()))
    }
}
```
mvcc 内部是一个具体的引擎，因此需要泛型实现 Engine 这个 trait ，而通过 Arc 和锁来使 mvcc 是一个线程安全的操作，其中的 begin 方法会返回一个 Mvcc事务。

mvcc事务定义：
```rust
pub struct MvccTransaction<E : Engine> {
    engine: Arc<Mutex<E>>
}

impl<E : Engine> MvccTransaction<E> {
    pub fn begin(eng: Arc<Mutex<E>>) -> Self{
        Self { engine: eng }
    }

    pub fn commit(&self) -> Result<()> {
        Ok(())
    }

    pub fn rollback(&self) -> Result<()> {
        Ok(())
    }

    // 插入数据
    pub fn set(&self,key:Vec<u8>,value:Vec<u8>) -> Result<()> {
        let mut eng = self.engine.lock()?;
        eng.set(key, value)
    }

    // 获取数据
    pub fn get(&self,key:Vec<u8>) -> Result<Option<Vec<u8>>> {
        let mut eng = self.engine.lock()?;
        eng.get(key)
    }


    pub fn scan_prefix(&self,prefix: Vec<u8>) -> Result<Vec<ScanResult>> {
        let mut eng = self.engine.lock()?;
        let mut iter = eng.scan_prefix(prefix);
        let mut v = Vec::new();
        while let Some((key,value)) = iter.next().transpose()? {
            v.push(ScanResult{key,value});
        }
        Ok(v)
    }
}
```
mvcc事务中的操作就是对引擎的调用，但是这里多了事务自己的方法，提交事务，回滚事务等。
## 小结
因此从流程上来看，上节通过生成执行节点，交给执行器，然后在 sql引擎层开启一个事务，这时，由于 sql引擎层的事务是封装了 mvcc的事务，其实就是开启了一个 mvcc的事务，这时通过接口就可以调用到存储引擎提供的接口，实现对数据的操作，这样我们的整个操作流程就完全打通了，只是其中具体的引擎还未实现，事务的一些内容还没有完善，等我们将存储引擎的接口实现后，就可以基本跑通流程，事务的提交，回滚等再流程跑通后再进行实现。
