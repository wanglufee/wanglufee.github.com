---
title: 数据库实现二词法分析
date: 2024-8-17 16:01:25
tags:
---
## 介绍
词法分析需要将用户传入的文本命令解析成对应的 TOKEN，因此需要识别每次词并实现其对应的 TOKEN。

例如：

用户传入的 SQL 语句：
```bash
select * from a;
```
对这一句命令进行分析，我们需要识别的字符包括 `select`, `*`,`from`,`a`,`;` 这五个。其中 `select`,`from`对应为关键字，而`*`和`;`则对应为特殊符号，有相应的含义，`a`这里表示表名，我们可以将其定义为字符串的 TOKEN。

同样关键字 TOKEN 还应该包括`create`,`insert`,这类操作相关的，以及`int`,`bool`这类表示类型的，以及`true`,`false`这种布尔值的等等。特殊字符还包括了`(`,`)`,`+`等这些，在进行词法分析时我们都需要将其识别，并输出对应的 TOKEN。

而且在识别一整个命令时，我们也需要将其中的空白字符，回车，换行进行相应的处理，最直接的是跳过。

## TOKEN 定义
TOKEN 的定义我们可以使用枚举类型来实现，当我们分析每个词是，应该对应为其中的一种。
```rust
pub enum Token {
    // 关键字
    Keyword(Keyword),
    // 其他类型的字符串Token，比如表名、列名
    Ident(String),
    // 字符串类型的数据
    String(String),
    // 数值类型，比如整数和浮点数
    Number(String),
    // 左括号 (
    OpenParen,
    // 右括号 )
    CloseParen,
    ...
}
```
其中字符串类型数据，数字类型数据，标识符我们在内部都使用了字符串来保存，关键字则需要自定义一个结构体来表示。
```rust
pub enum Keyword {
    Create,
    Table,
    Int,
    Integer,
    Boolean,
    Bool,
    Not,
    Null,
    Primary,
    Key,
    ...
}
```
关键字我们同样使用枚举类型来实现，每一个枚举值对应了不同的关键字。
## 词法分析器实现
接下来是我们的词法分析器，我们的词法分析器需要接受用户传入的命令字符，并对其进行迭代，识别每一个字符，我们内部使用 Peekable 结构体来实现，Peekable 由迭代器调用 peekable() 方法来创建，主要使用其中的 peek() 方法，此方法可以在不推进迭代器的条件下返回当前值。
```rust
pub struct Lexer<'a>{
    iter: Peekable<Chars<'a>>
}
```
并为解析器实现一个创建的方法
```rust
    pub fn new(sql_text: &'a str) -> Self {
        Self { 
            iter: sql_text.chars().peekable() 
        }
    }
```
这里我们通过输入的字符串创建迭代器，并调用 peekable() 方法来创建一个解析器。

解析器创建之后我们需要将内部的迭代器进行一些操作，以收集 TOKEN ，举个例子，我们将迭代器进行推进，如果遇到了 `'` 那么后面则是一个字符串，并且必须有对应的 `'` 闭合，而我们需要的则是引号中的内容，如果遇到了字符开头，那么这可能是一个关键字，或者是一个标识符，我们需要进行识别，如果遇到了数字，这下一个 TOKEN 对应了 int, 或者 float，在不断推进直到识别到末尾的`;`我们知道一个完整的语句中的词被我们全部识别了。

因此我们需要为解析器实现一个识别的 scan() 方法，此方法不断推进内部的 iter。
```rust
    // 扫描拿到下一个 token
    fn scan(&mut self) -> Result<Option<Token>> {
        // 首先清除 token 前空白字符
        self.erase_whitespace();

        match self.iter.peek() {
            Some('\'') => self.scan_string(),   // 如果遇到引号则进行字符串的识别
            Some(c) if c.is_ascii_digit() => Ok(self.scan_num()),  // 如果遇到数字则进行数字类型的识别
            Some(c) if c.is_alphabetic() => Ok(self.scan_ident()),  // 如果遇到字符开头我们则识别为标识符
            Some(_) => Ok(self.scan_symbol()),  // 其他相关的运算符或者括号之类同一识别为符号
            None => Ok(None),
        }
    }
```
这里处理完内部之后，我们还需要为解析器实现一个迭代器，这个迭代器则负责调用解析器自身的 scan() 方法，返回识别出的 TOKEN。
```rust
// 自定义迭代器，通过调用 scan 来扫描每个 token
impl<'a> Iterator for Lexer<'a> {
    type Item = Result<Token>;

    fn next(&mut self) -> Option<Self::Item> {
        match self.scan() {
            Ok(Some(token)) => Some(Ok(token)),
            Ok(None) => self
            .iter
            .peek()
            .map(|c| Err(Error::Parse(format!("[Lexer] Unexpeted character {}", c)))),
            Err(err) => Some(Err(err)),
        }
    }
}
```
属于解析器的迭代器每次向后推进都会返回一个相应的 TOKEN ，或者在识别到错误时返回错误。sacn() 函数在两种情况下会返回None，一种是完成了迭代，迭代器中以无内容，另一种是扫描到了当前情况下无法识别的字符，这时我们需要进行判断，如果是当前情况下输入了我们无法识别的字符，需要报错反馈。

此时我们的解析器就完成了相应的工作，将用户输入的文本命令解析为对应的 TOKEN 。