---
title: 数据库实现四执行计划
date: 2024-8-31 09:38:21
tags: 数据库
categories: rust，数据库
---
## 执行计划
从语法分析阶段结束后我们拿到了抽象语法树，之后这个抽象语法树需要交给执行计划，通过执行计划去生成对应的物理计划。

首先，我们可以定义一个执行计划的节点 Node，这个节点对应了不同的语句生成的抽象语法树，例如，创建表，查询表，插入数据等。然后我们定义一个执行计划 Plan，这个执行计划内部是执行计划节点。
## 执行节点定义
```rust
pub enum Node {
    CreateTable {
        schema: Table,
    },
    ...
}
```
我们希望执行节点能够和抽象语法树相对应，这里使用枚举，在定义时可以和抽象语法树的定义相对应。

在上一节实现的创建表的抽象语法树中主要包含了表名和列信息，这里我们定义一个 Table 结构体，来保存表信息。
```rust
pub struct Table {
    pub name: String,
    pub columns: Vec<Column>,
}

pub struct Column {
    pub name: String,
    pub datatype: DataType,
    pub nullable: bool,
    pub default: Option<Value>,
}
```
这里的字段与我们抽象语法树里的内容对应。
## 执行计划
执行计划当中包含了执行节点：
```rust
pub struct Plan(pub Node);
```
执行计划通过不同的执行节点，来生成相应的物理计划。

为执行计划提供一个 build 方法，传入参数使用解析生成的抽象语法树，生成一个执行计划。
```rust
impl Plan {
    pub fn build(stm: Statement) -> Self {
        Planner::new().build(stm)
    }
}
```
这里对抽象语法树的解析工作由 Planner 来完成。

对 Planner 的定义:
```rust
pub struct Planner;
```
由于 Planner 无需保存任何信息，只需要将传入的抽象语法树解析生成对应的 Plan 即可，因此在定义时无需任何内部元素。

为 Planner 实现解析逻辑：
```rust
impl Planner {
    pub fn new() -> Self {
        Self
    }

    pub fn build(&mut self, stm: Statement) -> Plan {
        Plan(self.build_statment(stm))
    }

    fn build_statment(&self, stm: Statement) -> Node {
        match stm {
            Statement::CreateTable { name, columns } => {
                Node::CreateTable { schema: Table{
                    name,
                    columns: columns.into_iter().map(|c| {
                        let nullable = c.nullable.unwrap_or(true);
                        let default = match c.default {
                            Some(expr) => {
                                Some(Value::from_expression(expr))
                            },
                            None if nullable => Some(Value::Null),
                            None => None,
                        };
                        Column {
                            name: c.name,
                            datatype: c.datatype,
                            nullable,
                            default,
                        }
                    }).collect(),
                } }
            },
        }
    }
}
```
通过内部的 build_statment 方法解析抽象语法树，生成执行节点，在通过 build 方法组装成一个 Plan。

由于执行节点出的 Column 与解析阶段的 Column 是不相同的，因此需要对抽象语法树生成的 columns，进行相应的修改。

至此我们通过解析抽象语法树，生成了对应的执行节点，并生成了对应的执行计划，下一节则会通过执行器，来执行生成的执行计划，最终通过底层的执行引擎，执行相关的操作。