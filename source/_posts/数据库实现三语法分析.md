---
title: 数据库实现三语法分析
date: 2024-8-25 09:19:19
tags: 数据库
categories: rust，数据库
---
## 语法分析
在此之前我们已经实现了词法分析，将每个词都转换为了对应的 TOKEN ，现在我们的工作就需要将这些 TOKEN 通过语法分析来连接成语句，并输出相应的语法树。
## 定义抽象语法树
这里我们以 CreateTable 为例，使用枚举来定义出抽象语法树。
```rust
// CREATE TABLE table_name (
//     [ column_name data_type [ column_constraint [...] ] ]
//     [, ... ]
//    );
pub enum Statement{
    CreateTable {
        name: String,
        columns: Vec<Column>,
    },
}
```
其中在创建表的过程中，我们需要拿到的数据有表名，以及列的信息。

列同样也需要存储一些信息，比如列名，列是否可以为空，列的类型，是否有默认值等。
```rust
pub struct Column {
    pub name: String,
    pub datatype: DataType,
    pub nullable: Option<bool>,
    pub default: Option<Expression>,
    ...
}
```
在创建表的过程中，可能指定默认值，而有些默认值会指定为表达式的形式，我们需要对表达式进行处理，这里我们只简单的实现一些常量的表达式处理。
```rust
pub enum Expression {
    Consts(Consts),
}

pub enum Consts {
    Null,
    Boolean(bool),
    Integer(i64),
    Float(f64),
    String(String),
}
```
## 词法解析过程
语法树相关的东西已经定义好了，接下来该进行语法分析，来输出一个抽象语法树了。

首先我们需要一个语法解析器，这个解析器要能拿到词法分析的结果，并去迭代每一个 TOKEN 。这里我们使用一个词法解析器来构造一个语法解析器。
```rust
pub struct Parser<'a> {
    lexer: Peekable<Lexer<'a>>,
}
```
这里我们就拿到了一个词法解析器的迭代器。之前我们在实现词法解析器的迭代器时，内部的工作就是调用词法解析，并返回一个 TOKEN ，这里我们只需要对词法解析器迭代，即可获取 TOKEN 。

解析时我们需要根据我们的语法规则来进行，首先我们希望每个语句能够以分号来结束，并且我们当前只解析单一的语句，那么分号之后不希望再有其他字符。
```rust
    pub fn parse(&mut self) -> Result<Statement> {
        let stmt = self.parse_statement()?;
        // 希望以分号结尾
        self.next_expect(Token::Semicolon)?;
        // 分号之后不再有内容
        if let Some(token) = self.peek()? {
            return Err(Error::Parse(format!("[Parser] Unexpected token {}", token)));
        }
        Ok(stmt)
    }
```
其中 parse_statement() 方法是解析的开始，并返回一个抽象语法树，解析完成后检查是否以分号结尾。
```rust
    fn parse_statement(&mut self) -> Result<Statement> {
        // 查看第一个字符
        match self.peek()? {
            Some(Token::Keyword(Keyword::Create)) => self.parse_ddl(),
            ...
        }
    }
```
解析开始时我们首先查看语句第一个 TOKEN ，以确定这条语句的类型，这里我们只有 Create 语句，当匹配到第一个 TOKEN 之后，则进行相应语句的解析工作。
```rust
    fn parse_ddl(&mut self) -> Result<Statement> {
        match self.next()? {
            // 期望是 Create 关键字
            Token::Keyword(Keyword::Create) => match self.next()? {
                // Create 关键字之后应该是 Table 关键字
                Token::Keyword(Keyword::Table) => self.parse_ddl_create_table(),
                token => Err(Error::Parse(format!("[Parser] Unexpected token {}", token))),
            },
            token => Err(Error::Parse(format!("[Parser] Unexpected token {}", token))),
        }
    }
```
根据我们定义的 Create 语句，在 Create 关键字后应该是 Table，同样的方式进行匹配，成功之后进行相应的处理，否则报错，语法错误。
```rust
    fn parse_ddl_create_table(&mut self) -> Result<Statement> {
        // 期望是表名
        let table_name = self.next_ident()?;

        // 表名之后是左括号
        self.next_expect(Token::OpenParen)?;

        // 解析列
        let mut columns = Vec::new();
        loop{
            columns.push(self.parse_ddl_column()?);
            if self.next_if_token(Token::Comma).is_none() {
                break;
            }
        }
        // 右括号
        self.next_expect(Token::CloseParen)?;
        Ok(Statement::CreateTable { 
            name: table_name, 
            columns: columns 
        })
    }
```
前面的语法符合，那么我们接下来拿到的就应该是表名，列信息，列信息我们在括号内进行，因此需要匹配两个括号，中间通过循环来解析列。我们定义的每一列信息中间以逗号分隔，当我们解析了一个列信息时，查看下一个字符是否为逗号，如果是，那么还有下一个列，否则列解析完成，跳出循环。最后使用拿到的表名和列信息来构造我们的抽象语法树。
```rust
    fn parse_ddl_column(&mut self) -> Result<Column> {
        let mut column = Column{
            name: self.next_ident()?,
            datatype: match self.next()? {
                Token::Keyword(Keyword::Bool) | Token::Keyword(Keyword::Boolean) => DataType::Boolean,
                Token::Keyword(Keyword::Int) | Token::Keyword(Keyword::Integer) => DataType::Integer,
                Token::Keyword(Keyword::Float) | Token::Keyword(Keyword::Double) => DataType::Float,
                Token::Keyword(Keyword::String) | Token::Keyword(Keyword::Text) | Token::Keyword(Keyword::Varchar) => DataType::String,
                token => return Err(Error::Parse(format!("[Parser] Unexpected token {}", token))),
            },
            nullable: None,
            default: None,
        };
        // 判断下一个是否是关键字
        while let Some(Token::Keyword(keyword)) = self.next_if_keyword() {
            match keyword {
                Keyword::Null => column.nullable = Some(true),
                Keyword::Not => {
                    self.next_expect(Token::Keyword(Keyword::Null))?;
                    column.nullable = Some(false)
                }
                Keyword::Default => column.default = Some(self.parse_expression()?),
                k => return Err(Error::Parse(format!("[Parser] Unexpected keyword {}", k))),
            }
        }

        Ok(column)
    }
```
列的解析，我们首先拿到的是列名，列名之后跟着类型，这两个是固定的，之后则可能出现多种情况，指定了是否非空，是否指定了默认值等，因此需要我们进行匹配，分别作出判断，如果出现了其他的关键字，那么我们需要进行报错，语法错误。最后将列信息返回。

最后则是对默认值的解析工作了
```rust
    fn parse_expression(&mut self) -> Result<Expression> {
        Ok(match self.next()? {
            Token::Number(n) => {
                if n.chars().all(|c| c.is_ascii_digit()) {
                    ast::Consts::Integer(n.parse()?).into()
                } else {
                    ast::Consts::Float(n.parse()?).into()
                }
            },
            Token::String(s) => ast::Consts::String(s).into(),
            Token::Keyword(Keyword::True) => ast::Consts::Boolean(true).into(),
            Token::Keyword(Keyword::False) => ast::Consts::Boolean(false).into(),
            Token::Keyword(Keyword::Null) => ast::Consts::Null.into(),
            t => {
                return Err(Error::Parse(format!(
                    "[Parser] Unexpected expression token {}",
                    t
                )))
            }
        })
    }
```
因为我们的表达是只支持了几种常量类型，因此直接使用对应的模式匹配即可。

至此我们完成了 Create 语句的解析工作，并生成了抽象语法树。