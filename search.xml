<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rust基础知识</title>
      <link href="/2024/03/20/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/03/20/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><p>在rust中通过 let 关键字来声明一个变量，并未变量绑定一个值，变量默认为不可变，即初始化之后无法对变量做出修改，可以不显示指定变量类型，编译器会自动推断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line">a = <span class="number">10</span>  <span class="comment">// 无法修改，会出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">5</span>;   <span class="comment">// 可以在变量名后跟 :变量类型  的方式来指定变量类型</span></span><br></pre></td></tr></table></figure><p>通过 mut 关键字使得变量具有可变性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">5</span>;  <span class="comment">// 通过 mut 关键字声明变量，则变量具有可变性</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 可以更改变量</span></span><br></pre></td></tr></table></figure><p>常量在rust中与不可变变量类似，但常量在声明时需要使用 const 关键字，并且在声明时必须指定类型，赋值只能为一个常量表达式，不能为一个需要在运行时得出的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM: <span class="type">i32</span> = <span class="number">100</span> * <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>rust中变量具有遮蔽行为，即在一个变量定义之后，可以使用相同的变量名来遮蔽之前的变量。遮蔽与可变性不同，遮蔽可以理解为重新创建了一个新的变量，类型可与之前不同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 在此之前变量 a 的值为5，之后值为 hello</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>rust中函数的入口时 main 函数，默认情况下 main 函数没有参数和返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数需要显示的指定类型，返回值类型则跟在小括号后。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="comment">// 需要一个 i32 类型的参数，返回一个 i32 的值。</span></span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句与表达式，语句不会返回值，表达式会返回值。表达式可以赋值给另一个变量，而语句不可以。同理表达式可以作为函数的返回值，比如上面函数返回 x</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;   <span class="comment">// 这是一条语句，没有返回值</span></span><br><span class="line">a   <span class="comment">// 这是一个表达式，会返回 a </span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>if 判断语句，直接在 if 后跟判断的条件即可，注意在 rust 中 if 是一个表达式，会产生值，可以赋值给另一个变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&gt;5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&lt;=5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回两个数中的较大值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">max</span> = <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// if 后同样可以接多个 else if</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">90</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">80</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">70</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop 循环语句，执行循环，直到代码指定跳出，否则一直循环下去，loop 同样属于语句，可以有返回值，返回值可通过 break 返回。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> a;    <span class="comment">// 这里 break 指定跳出循环，并返回值给变量 b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>while 条件循环，当条件为真时，执行循环，为假时跳出循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">100</span> &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环，相比 while 循环，for 循环在遍历集合中的元素时更加方便。并且不会出现越界的行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&#123;i&#125;=&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链demo</title>
      <link href="/2024/02/10/%E5%8C%BA%E5%9D%97%E9%93%BEdemo/"/>
      <url>/2024/02/10/%E5%8C%BA%E5%9D%97%E9%93%BEdemo/</url>
      
        <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>区块链是一个公开的，不可篡改的分布式数据库，每个人都有一个完整的或部分的副本，区块链应用部署于每个节点上，必须通过大多数节点的认同，才可以向区块链中添加内容。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块链由一个一个区块构成，所有信息也全部存在于区块之中，区块还包含了额外的其他信息，包括版本信息，时间戳，前一个区块的哈希值，以及当前区块的哈希值。</p><p>而在这个demo中我们的区块里只需要包含一些简单信息，我们目前的区块仅仅包含了如下信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">u128</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    prev_block_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在bitcoin中区块存在区块头，区块头是一个独立的结构体，时间戳，hash这些在区块头中，而区块头和交易信息等构成了区块。为了简便起见，我将信息和时间戳，hash等全部放入区块结构体中。</p><p>其中时间戳是记录当前区块的时间，内容则是每个节点需要向区块中记录的信息，前一个hash值，记录上一个区块的hash，当前hash则计算前三个字段的hash。</p><p>hash计算在bitcoin中是非常重要的一部分，正是因为hash计算才能保证bitcoin的安全，hash具有不可逆性，抗碰撞性，很难找到两个不同的数据具有同样的hash值，也无法通过hash值来反推数据，所以如果想要找到符合条件的hash值，那么唯一的方法就是不断计算，直到尝试出正确的解，正是由于这种特性，使得hash可以用来作为工作量的评估标准。在工作量证明部分我们会再看。</p><p>计算hash设置区块内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">set_hash</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 计算时间戳</span></span><br><span class="line">    <span class="keyword">self</span>.timestamp = SystemTime::<span class="title function_ invoke__">now</span>()</span><br><span class="line">                        .<span class="title function_ invoke__">duration_since</span>(SystemTime::UNIX_EPOCH)?</span><br><span class="line">                        .<span class="title function_ invoke__">as_millis</span>();</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = (<span class="keyword">self</span>.timestamp,<span class="keyword">self</span>.data.<span class="title function_ invoke__">clone</span>(),<span class="keyword">self</span>.prev_block_hash.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = <span class="title function_ invoke__">serialize</span>(&amp;content)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;bytes);</span><br><span class="line">    <span class="keyword">self</span>.hash = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个新区块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_block</span>(data: <span class="type">String</span>,prev_block_hash: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Block&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">block</span> = Block&#123;</span><br><span class="line">        timestamp: <span class="number">0</span>,</span><br><span class="line">        data,</span><br><span class="line">        prev_block_hash,</span><br><span class="line">        hash: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = block.<span class="title function_ invoke__">set_hash</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>有了区块，就可以开始构建区块链了，区块链中后一个区块指向前一个区块，根据时间顺序不停向后拓展，我们可以方便的获取最新的区块。这里我们用一个集合来保存区块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Blockchain</span> &#123;</span><br><span class="line">    blocks: <span class="type">Vec</span>&lt;Block&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在区块链中，第一个出现的块被称为创世区块，也是整个链的起点，初始化一个区块链，在初始化的过程中，需要生成一个创世区块。<br>为区块添加生成创世区块方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_genesis_block</span>() <span class="punctuation">-&gt;</span> Block &#123;</span><br><span class="line">    Block::<span class="title function_ invoke__">new_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;创世区块&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">new</span>()).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个链：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Blockchain &#123;</span><br><span class="line">    Blockchain&#123;</span><br><span class="line">        blocks: <span class="built_in">vec!</span>[Block::<span class="title function_ invoke__">new_genesis_block</span>()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向区块链上添加区块:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_block</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,data:<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">prev</span> = <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_block</span> = Block::<span class="title function_ invoke__">new_block</span>(data, prev.<span class="title function_ invoke__">get_hash</span>())?;</span><br><span class="line">    <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">push</span>(new_block);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok基本的区块和区块链已经完成，来测试一下看结果如何。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bc</span> = Blockchain::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = bc.<span class="title function_ invoke__">add_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;手动添加一个区块&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = bc.<span class="title function_ invoke__">add_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;工作996真的太烦了&quot;</span>));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,bc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Blockchain &#123;</span><br><span class="line">    blocks: [</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;创世区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;4641856e7ada2e715ac99e8caa4410bcf98a6a36c38cb1729217ae617facc07d&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;手动添加一个区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;4641856e7ada2e715ac99e8caa4410bcf98a6a36c38cb1729217ae617facc07d&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;85f61860660b0c1b73c24a433d821db1951c3f554d535a5f60aaf2bb4d98b0f7&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;工作996真的太烦了&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;85f61860660b0c1b73c24a433d821db1951c3f554d535a5f60aaf2bb4d98b0f7&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;fc90e189dc162fd68edfce5376c32fd7347e19a36deee2d8da2c588356081516&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区块链雏形完成。</p><h1 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h1><p>工作量证明在区块链中是非常重要的一部分，同时也保证了区块链的安全性。就如同我们在生活中一样，需要通过努力工作，才能拿到相应的报酬，而在区块链中每个矿工通过进行一定量的工作，来挖出一个区块，并从区块中得到一定的奖励。这样的机制就叫做工作量证明。在bitcoin中区块的生成速度被控制在10分钟左右，而工作则是寻找符合条件的hash值，只有找到符合条件的hash值，那么这个区块才算是一个合法的区块，所以对于矿工而言，就需要不断计算hash值。</p><h2 id="hash计算"><a href="#hash计算" class="headerlink" title="hash计算"></a>hash计算</h2><p>通过hash函数可以计算给定数据的hash值，hash函数会输出一个固定长度的哈希值，hash具有几个特点：</p><ul><li>从数据可以计算出hash，而从hash无法反推出数据。</li><li>每个数据的hash值唯一</li><li>对数据做很小的修改，hash值会变的完全不同</li><li>无法根据特定的hash值，去寻找生成这个hash值的数据</li></ul><p>在区块链中hash被用来保证块的一致性，区块中包含有前一个区块的hash值，如果要修改一个区块，那么这个区块之后的所有区块都会被影响，因此使得篡改区块链上的数据所要付出的代价会变得非常大。</p><p>由于无法知道生成一个特定的hash值所需要的数据，所以如果要生成一个符合特定条件的hash值唯一的方法是计算，在bitcoin中有一个nonce值，这个值在生成区块的过程中可以被改变，由此来计算不同的hash，而根据对hash值的要求不同，计算难度也完全不同。</p><p>因此我们在区块的实现中添加一个nonce值，用来计算hash，添加一个TARGET，用来控制区块生成的难度。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TARGET_HEXS: <span class="type">usize</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 区块结构体</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">u128</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    prev_block_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">    nonce: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中TARGET是指生成的hash值的前TARGET位需要为0。</p><p>工作量证明即不停修改nonce值，计算出一个符合TARGET难度的hash值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_proof_of_work</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">validate</span>()? &#123;</span><br><span class="line">        <span class="keyword">self</span>.nonce += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_hash_data</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;data);</span><br><span class="line">    <span class="keyword">self</span>.hash = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">validate</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_hash_data</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec1</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    vec1.<span class="title function_ invoke__">resize</span>(TARGET_HEXS, <span class="string">&#x27;0&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(hash[<span class="number">0</span>..TARGET_HEXS] == <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(vec1)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下添加工作量证明之后的区块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Blockchain &#123;</span><br><span class="line">    blocks: [</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241352238,</span><br><span class="line">            data: <span class="string">&quot;创世区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;0000f1ee1053aeff7a7184ae34907e79a4ce439007b26cff9f22e7a41c4ac4b8&quot;</span>,</span><br><span class="line">            nonce: 34797,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241352358,</span><br><span class="line">            data: <span class="string">&quot;手动添加一个区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;0000f1ee1053aeff7a7184ae34907e79a4ce439007b26cff9f22e7a41c4ac4b8&quot;</span>,        </span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;0000946eae88f47da86be7d067853e5d4cdc0bef6223e689112c6217f4f8cd29&quot;</span>,</span><br><span class="line">            nonce: 118886,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241353153,</span><br><span class="line">            data: <span class="string">&quot;工作996真的太烦了&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;0000946eae88f47da86be7d067853e5d4cdc0bef6223e689112c6217f4f8cd29&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;00002a7035984cf78cde09c3d67669c6e4edb055a17d3a195470910c2bb3fd71&quot;</span>,</span><br><span class="line">            nonce: 34257,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到hash值的前TARGET位为0。</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年度总结</title>
      <link href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2023年算是我工作的第一年，毕竟我在2023年年初才转正，工作之后才发现时间过的又快了一些，一年中发生了很多事情，我需要花时间来梳理一下，总结下今年。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>首先说下工作上的吧，毕竟已经是一个彻彻底底的打工人了，在华为工作的这一年算是学到了一些东西，但不是很多，在年初的时候我从防火墙的策略特性更换到了防火墙的PKI特性，最开始还有点不熟悉，但是经过大概半个月的了解我逐渐了解了PKI特性，上手之后还算轻松，而且PKI特性相对比较稳定，平时没有什么比较繁忙的事务，在PKI特性里也学到了很多，了解了加密，证书等等。在国庆之后，由于一些原因我换岗到了AR，在AR这边负责转发性能的测试，AR的事务看起来没有防火墙那边紧急，更重要的是AR团队在别的城市，不能和他们面对面交流让我有点不太适应。但总体还好，只是转发性能的脚本之前的人写的很烂，很多公用的操作全部写在方法里，没能提取出来，看这些脚本真的很心累。今年也经历了第一次涨薪，涨了500，说实话真不算多，但我也不能说什么，可能我只值这500。  </p><p>总体看起来我工作方面就是不温不火，没什么亮点，唯一让人开心的是绩效合格了，能拿到个年终奖。明年的工作暂时还没什么计划，不过我想换一份工作了，希望能换到一份rust开发的工作。不过说起来现在的rust开发是真的少（也不知道是不是我找的方式不对），基本大部分都和区块链相关，要么和web3相关，可惜这两者我都不太了解。不过国内很多大厂也在开始使用rust了，或许明年岗位会多一些？判断以后的形式我并不擅长，感觉我也没有什么远见。总之就是等机会吧，自己学习下，有机会的时候希望能把握住。  </p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>上班之后学习的时间大大减少了，不过还是能抽出一些时间来看看的。今年的学习情况也是一言难尽。  </p><p>在前半年的时候，我还每天回家会抽出0.5-1小时来看《深入理解计算机系统》，但是在6月份新冠阳了之后，感觉身体有些不舒服就没在看了，以为只是停一段时间，结果一直到年尾了也没再看过，真的不能懒惰。养成一个好习惯需要几个月时间，但忘掉一个好习惯却只需要几天。</p><p>今年在公司还关注到了rust的社区，学习了rust，感觉rust真的是一门很好的语言，我很喜欢。只是学习曲线比较陡峭，而且由于工作原因我也只能断断续续的学，学习效率有点低。不过经过一年时间，我也算是入门了吧（毕竟掌握了基本语法，能写出一些东西，学会了如何在文档中查找自己需要的东西）。只是到了rust异步那块，实在有点难啃，而且暂时没找到好的适合学习的项目（大部分好的项目基本都体量很大，拿来学习的话可能并不是一个好的选择），所以异步这块基本算是只写过书上的例子，还没有自己实际写过东西。和异步一样的还有unsafe rust，这块我完全没有用到，理解也很浅。但是感觉还好，毕竟safe rust我都还没完全掌握，等之后总有机会到unsafe领域的。  </p><p>由于受到rust的影响，今年还学习了区块链。区块链学习主要是看了肖臻老师的公开课，老师讲了比特币和以太坊，这是两个非常经典的基于区块链技术。区块链的思想真的很棒，实现了去中心化，可以去掉传统的第三方，直接的进行点对点的服务。而且以太坊中也有了更多的扩展，出现了智能合约。而且肖臻老师讲课真的是苏格拉底式的讲课，老师说的那句 <strong>知识改变命运，但一知半解的知识并不能让你过的更好。</strong> 让我深有感触。学习中还是要把知识理解透彻，如果只是一知半解，就像一个定时炸弹，你不知道它什么时候会爆炸，但它总有爆炸的一天。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>工作之后不仅学习时间变少了，生活时间也同样减少。每天下班基本到家就晚上9点多了，洗一洗就到了晚上10点多了，想做点自己的事情都完全没有时间。最开始每天晚上还能锻炼一下，做几组俯卧撑。也是在第一次阳了之后就没在做了。说起来6月份阳的那次也是真的很难受，发烧了1天半时间，最高烧到了38.9度，当时躺在床上动也动不了，不想再次体验了。不过比较幸运的是，12月份我的朋友们基本都甲流了，而我恰好逃过一劫，甲流没来找我，哈哈。平时生活也平平淡淡，节假日基本在家打游戏，偶尔出去和朋友一起玩，部门也没怎么组织团建，只组织了一次，还是大部门一起的，我们组单独的根本没组织过（最惨的是到最后我们团建的钱没怎么花过，然后年底被收走了，感觉亏损一个亿啊！！！）。然后今年12月体检，体检结果还好，各个内脏都好好的，没什么毛病，算是一个好消息。没东西了，上班之后基本没什么生活。彻彻底底的打工人（牛马）。</p><h2 id="未来一年"><a href="#未来一年" class="headerlink" title="未来一年"></a>未来一年</h2><p>新的一年希望能够变得越来越好，能养成几个好习惯。身体健康，工作顺利（感觉不会），希望家人也能健健康康。妖魔鬼怪快离开！妖魔鬼怪快离开！妖魔鬼怪快离开！<br>新的一年定几个小目标（能完成60%就可以了）：</p><ul><li>每周能去2-3次健身房锻炼身体。</li><li>继续学习rust，巩固基础，学习异步和unsafe，并且能自己写几个相关的项目demo，加深理解。</li><li>每两周去看个电影。</li><li>坚持写博客，把自己的所见所闻记录下来，把自己的学习感悟记录下来。</li><li>希望能换一份工作，想从事rust开发或者区块链开发（希望面试官们捞捞我）。</li><li>坚持读书，一年能读2本书（目前想读《计算机科学中的数学》，另一本暂时没定，毕竟也不知道这本能不能读完）</li></ul><p>这就是我新一年想做的事情，希望能坚持下来，新的一年加油。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/31/hello-world/"/>
      <url>/2023/12/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
