<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux驱动学习一</title>
      <link href="/2024/04/13/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
      <url>/2024/04/13/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="linux内核编译"><a href="#linux内核编译" class="headerlink" title="linux内核编译"></a>linux内核编译</h1><blockquote><p>linux 内核配置</p></blockquote><p>比较推荐的是通过命令 <code>make menuconfig</code> 命令来进行配置，它不依赖于QT或GTK+，且非常直观，运行此命令配置之后，会生成一个 .config 配置文件，记录哪些部分被编译进内核，哪些部分被编译为模块，或者不编译。</p><p>linux 配置系统由三部分组成</p><ul><li>Makefile: 分布在Linux内核源代码中，定义Linux内核的编译规则。</li><li>Kconfig: 给用户提供配置选择的功能</li><li>配置工具: 包括配置命令解释器和配置用户界面</li></ul><p>首先来看 Kconfig 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config TTY_PRINTK</span><br><span class="line">       tristate <span class="string">&quot;TTY driver to output user messages via printk&quot;</span></span><br><span class="line">       depends on EXPERT &amp;&amp; TTY</span><br><span class="line">       default n</span><br><span class="line">       ---<span class="built_in">help</span>---</span><br><span class="line">        If you say Y here, the support <span class="keyword">for</span> writing user messages (i.e.</span><br><span class="line">        console messages) via printk is available.</span><br><span class="line">        The feature is useful to inline user messages with kernel</span><br><span class="line">        messages.</span><br><span class="line">        In order to use this feature, you should output user messages</span><br><span class="line">        to /dev/ttyprintk or redirect console to this TTY.</span><br><span class="line">        If unsure, say N.</span><br></pre></td></tr></table></figure><p>config 后跟的是配置项的符号， tristate 代表这个选项是一个三态选项，分别为 Y , N , M,其中 Y 表示编译进内核中， N 表示不进行编译， M 表示编译成内核模块，后面的字符则是在配置界面显示的内容。此处除了 tristate 还有 bool 等。 depends on 则表示这个模块依赖的模块有哪些，多个模块用 <code>&amp;&amp;</code> 来连接， default 表示默认值。 help 下跟的则是在配置中的帮助信息。</p><p>接下来看 Kbuild Makefile 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONfiG_ISDN) += isdn.o</span><br><span class="line">obj-$(CONfiG_ISDN_PPP_BSDCOMP) += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure><p>此处 obj-$(xxx) 其中的 xxx 即为配置项符号， 命名的方式是在 Kconfig 的符号前加了 CONFIG_ 字段， 当其值为 y 时，会根据后面的 .o 文件去找对应的 .c 或 .s 文件，编译进内核中，当为 n 时，则不进行编译， 为 m 时，则寻找对应的文件，编译为模块的形式， 这里对应了用户配置时的选择。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Makefile for the linux ext2-filesystem routines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">obj-$(CONfiG_EXT2_FS) += ext2.o</span><br><span class="line">ext2-y := balloc.o dir.o file.o fsync.o ialloc.o inode.o \</span><br><span class="line">       ioctl.o namei.o super.o symlink.o</span><br></pre></td></tr></table></figure><p>若一个模块由多个文件构成，则会去找对应的 .o 文件，最终链接生成最终的 .o 文件。此处若配置了 ext2.o ，则会去找 balloc.o  dir.o 等文件，最终生成 ext2.o 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONfiG_EXT2_FS) += ext2/</span><br></pre></td></tr></table></figure><p>目录层次，当配置为 y 或者 m 时，会迭代 ext2 目录。</p><h1 id="linux内核模块程序结构"><a href="#linux内核模块程序结构" class="headerlink" title="linux内核模块程序结构"></a>linux内核模块程序结构</h1><p>一般内核模块主要由以下几部分组成</p><ul><li>模块加载函数： 当使用 <code>insmod</code> 或 <code>modprobe</code> 命令加载模块时，模块加载函数被调用，完成初始化工作。</li><li>模块卸载函数： 当使用 <code>rmmod</code> 命令卸载模块时，会调用模块卸载函数，完成卸载功能。</li><li>模块许可声明： 声明内核模块的许可权限。(大多数情况下license为 GPL v2)</li><li>模块参数(可选)： 模块加载时可传递给模块的值。</li><li>模块导出符号(可选)： 内核模块导出的符号，若导出则其他模块可以使用本模块中的变量或函数。</li><li>模块作者等信息声明(可选)</li></ul><h2 id="模块加载函数"><a href="#模块加载函数" class="headerlink" title="模块加载函数"></a>模块加载函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _ _init <span class="title function_">initialization_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(initialization_function);</span><br></pre></td></tr></table></figure><p>模块加载函数一般以 <strong>__init</strong> 声明，而模块加载函数以 <strong>module_init(函数名)</strong> 的形式被指定，它返回整形值，模块初始化成功时返回0。失败则返回相应的错误码。</p><p>还可以使用 <strong>request_module(module_name)</strong> 来灵活加载其他内核模块。</p><h2 id="模块卸载函数"><a href="#模块卸载函数" class="headerlink" title="模块卸载函数"></a>模块卸载函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _ _exit <span class="title function_">cleanup_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/* 释放代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure><p>内核卸载函数一般以 <strong>__exit</strong> 声明，模块卸载函数在模块卸载时执行，不返回任何值，必须以 <strong>module_exit(函数名)</strong> 的形式来指定。若模块被编译进内核，则卸载函数会被省略。</p><h2 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *book_name = <span class="string">&quot;dissecting Linux Device Driver&quot;</span>;</span><br><span class="line">module_param(book_name, charp, S_IRUGO);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> book_num = <span class="number">4000</span>;</span><br><span class="line">module_param(book_num, <span class="type">int</span>, S_IRUGO);</span><br></pre></td></tr></table></figure><p>可以使用 <strong>modele_param(参数名,参数类型,参数读&#x2F;写权限)</strong> 为模块定义一个参数。 在加载模块时可以向模块传递参数 <code>insmod 模块名 参数名=参数值</code>。如果不传递，则使用定义的缺省值。 参数的类型可以为<br><strong>byte、short、ushort、int、uint、long、ulong、charp（字符指针）​、bool或invbool（布尔的反）</strong>。</p><p>此外模块还可以拥有参数数组，可以通过 <code>module_param_array(数组名,数组类型,数组长,参数读/写权限)</code> 来定义。</p><p>模块被加载后在 &#x2F;sys&#x2F;module 目录下会出现以模块名命名的目录，如果包含可读写的参数时，目录下还将包含 parameters 目录，其中包含参数名的一系列文件节点。</p><h2 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名);</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名);</span><br></pre></td></tr></table></figure><p>模块可以使用上述两个宏导出符号，其他模块使用时只需要提前声明即可。 <strong>EXPORT_SYMBOL_GPL</strong>导出的符号只适用于包含GPL许可权的模块。</p><h2 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCRIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure><p>上述宏分别用于声明模块的作者、描述、版本、设备表和别名。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust基础知识</title>
      <link href="/2024/03/20/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/03/20/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><p>在rust中通过 let 关键字来声明一个变量，并未变量绑定一个值，变量默认为不可变，即初始化之后无法对变量做出修改，可以不显示指定变量类型，编译器会自动推断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line">a = <span class="number">10</span>  <span class="comment">// 无法修改，会出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">5</span>;   <span class="comment">// 可以在变量名后跟 :变量类型  的方式来指定变量类型</span></span><br></pre></td></tr></table></figure><p>通过 mut 关键字使得变量具有可变性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">5</span>;  <span class="comment">// 通过 mut 关键字声明变量，则变量具有可变性</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 可以更改变量</span></span><br></pre></td></tr></table></figure><p>常量在rust中与不可变变量类似，但常量在声明时需要使用 const 关键字，并且在声明时必须指定类型，赋值只能为一个常量表达式，不能为一个需要在运行时得出的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM: <span class="type">i32</span> = <span class="number">100</span> * <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>rust中变量具有遮蔽行为，即在一个变量定义之后，可以使用相同的变量名来遮蔽之前的变量。遮蔽与可变性不同，遮蔽可以理解为重新创建了一个新的变量，类型可与之前不同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 在此之前变量 a 的值为5，之后值为 hello</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>rust中函数的入口时 main 函数，默认情况下 main 函数没有参数和返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数需要显示的指定类型，返回值类型则跟在小括号后。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="comment">// 需要一个 i32 类型的参数，返回一个 i32 的值。</span></span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句与表达式，语句不会返回值，表达式会返回值。表达式可以赋值给另一个变量，而语句不可以。同理表达式可以作为函数的返回值，比如上面函数返回 x</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;   <span class="comment">// 这是一条语句，没有返回值</span></span><br><span class="line">a   <span class="comment">// 这是一个表达式，会返回 a </span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>if 判断语句，直接在 if 后跟判断的条件即可，注意在 rust 中 if 是一个表达式，会产生值，可以赋值给另一个变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&gt;5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&lt;=5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回两个数中的较大值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">max</span> = <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// if 后同样可以接多个 else if</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">90</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">80</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">70</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop 循环语句，执行循环，直到代码指定跳出，否则一直循环下去，loop 同样属于语句，可以有返回值，返回值可通过 break 返回。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> a;    <span class="comment">// 这里 break 指定跳出循环，并返回值给变量 b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>while 条件循环，当条件为真时，执行循环，为假时跳出循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">100</span> &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环，相比 while 循环，for 循环在遍历集合中的元素时更加方便。并且不会出现越界的行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&#123;i&#125;=&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>所有权是rust特有的特性，同样也是核心功能之一，保证rust在没有gc的情况下还能够做到内存安全。</p><p>rust所有权有三个规则：</p><ul><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li><li>值在任一时刻只有一个所有者。</li><li>当所有者离开作用域，值将被丢弃。</li></ul><p>首先来看作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                               <span class="comment">// s 未进行声明，不可使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;            <span class="comment">// 声明变量 s 变量 s 有效，可使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;                               <span class="comment">// 离开作用域，变量 s 无效，值被丢弃</span></span><br></pre></td></tr></table></figure><p>接下来需要介绍一下栈内存和堆内存，在rust中，如果数据的大小是固定的且已知的，那么会被存放在栈内存中，否则将会被存放在堆内存，所有权更主要是管理堆上的内存空间。</p><p>以String类型为例：String字符串在创建是未知大小，所以会被分配到堆空间。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);      <span class="comment">// 在堆空间分配内存存放值</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);                    <span class="comment">// 在字符串值后追加内容</span></span><br><span class="line">&#125;                                           </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链demo</title>
      <link href="/2024/02/10/%E5%8C%BA%E5%9D%97%E9%93%BEdemo/"/>
      <url>/2024/02/10/%E5%8C%BA%E5%9D%97%E9%93%BEdemo/</url>
      
        <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>区块链是一个公开的，不可篡改的分布式数据库，每个人都有一个完整的或部分的副本，区块链应用部署于每个节点上，必须通过大多数节点的认同，才可以向区块链中添加内容。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块链由一个一个区块构成，所有信息也全部存在于区块之中，区块还包含了额外的其他信息，包括版本信息，时间戳，前一个区块的哈希值，以及当前区块的哈希值。</p><p>而在这个demo中我们的区块里只需要包含一些简单信息，我们目前的区块仅仅包含了如下信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">u128</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    prev_block_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在bitcoin中区块存在区块头，区块头是一个独立的结构体，时间戳，hash这些在区块头中，而区块头和交易信息等构成了区块。为了简便起见，我将信息和时间戳，hash等全部放入区块结构体中。</p><p>其中时间戳是记录当前区块的时间，内容则是每个节点需要向区块中记录的信息，前一个hash值，记录上一个区块的hash，当前hash则计算前三个字段的hash。</p><p>hash计算在bitcoin中是非常重要的一部分，正是因为hash计算才能保证bitcoin的安全，hash具有不可逆性，抗碰撞性，很难找到两个不同的数据具有同样的hash值，也无法通过hash值来反推数据，所以如果想要找到符合条件的hash值，那么唯一的方法就是不断计算，直到尝试出正确的解，正是由于这种特性，使得hash可以用来作为工作量的评估标准。在工作量证明部分我们会再看。</p><p>计算hash设置区块内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">set_hash</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 计算时间戳</span></span><br><span class="line">    <span class="keyword">self</span>.timestamp = SystemTime::<span class="title function_ invoke__">now</span>()</span><br><span class="line">                        .<span class="title function_ invoke__">duration_since</span>(SystemTime::UNIX_EPOCH)?</span><br><span class="line">                        .<span class="title function_ invoke__">as_millis</span>();</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = (<span class="keyword">self</span>.timestamp,<span class="keyword">self</span>.data.<span class="title function_ invoke__">clone</span>(),<span class="keyword">self</span>.prev_block_hash.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = <span class="title function_ invoke__">serialize</span>(&amp;content)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;bytes);</span><br><span class="line">    <span class="keyword">self</span>.hash = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个新区块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_block</span>(data: <span class="type">String</span>,prev_block_hash: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Block&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">block</span> = Block&#123;</span><br><span class="line">        timestamp: <span class="number">0</span>,</span><br><span class="line">        data,</span><br><span class="line">        prev_block_hash,</span><br><span class="line">        hash: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = block.<span class="title function_ invoke__">set_hash</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>有了区块，就可以开始构建区块链了，区块链中后一个区块指向前一个区块，根据时间顺序不停向后拓展，我们可以方便的获取最新的区块。这里我们用一个集合来保存区块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Blockchain</span> &#123;</span><br><span class="line">    blocks: <span class="type">Vec</span>&lt;Block&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在区块链中，第一个出现的块被称为创世区块，也是整个链的起点，初始化一个区块链，在初始化的过程中，需要生成一个创世区块。<br>为区块添加生成创世区块方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_genesis_block</span>() <span class="punctuation">-&gt;</span> Block &#123;</span><br><span class="line">    Block::<span class="title function_ invoke__">new_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;创世区块&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">new</span>()).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个链：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Blockchain &#123;</span><br><span class="line">    Blockchain&#123;</span><br><span class="line">        blocks: <span class="built_in">vec!</span>[Block::<span class="title function_ invoke__">new_genesis_block</span>()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向区块链上添加区块:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_block</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,data:<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">prev</span> = <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_block</span> = Block::<span class="title function_ invoke__">new_block</span>(data, prev.<span class="title function_ invoke__">get_hash</span>())?;</span><br><span class="line">    <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">push</span>(new_block);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok基本的区块和区块链已经完成，来测试一下看结果如何。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bc</span> = Blockchain::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = bc.<span class="title function_ invoke__">add_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;手动添加一个区块&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = bc.<span class="title function_ invoke__">add_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;工作996真的太烦了&quot;</span>));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,bc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Blockchain &#123;</span><br><span class="line">    blocks: [</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;创世区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;4641856e7ada2e715ac99e8caa4410bcf98a6a36c38cb1729217ae617facc07d&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;手动添加一个区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;4641856e7ada2e715ac99e8caa4410bcf98a6a36c38cb1729217ae617facc07d&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;85f61860660b0c1b73c24a433d821db1951c3f554d535a5f60aaf2bb4d98b0f7&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;工作996真的太烦了&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;85f61860660b0c1b73c24a433d821db1951c3f554d535a5f60aaf2bb4d98b0f7&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;fc90e189dc162fd68edfce5376c32fd7347e19a36deee2d8da2c588356081516&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区块链雏形完成。</p><h1 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h1><p>工作量证明在区块链中是非常重要的一部分，同时也保证了区块链的安全性。就如同我们在生活中一样，需要通过努力工作，才能拿到相应的报酬，而在区块链中每个矿工通过进行一定量的工作，来挖出一个区块，并从区块中得到一定的奖励。这样的机制就叫做工作量证明。在bitcoin中区块的生成速度被控制在10分钟左右，而工作则是寻找符合条件的hash值，只有找到符合条件的hash值，那么这个区块才算是一个合法的区块，所以对于矿工而言，就需要不断计算hash值。</p><h2 id="hash计算"><a href="#hash计算" class="headerlink" title="hash计算"></a>hash计算</h2><p>通过hash函数可以计算给定数据的hash值，hash函数会输出一个固定长度的哈希值，hash具有几个特点：</p><ul><li>从数据可以计算出hash，而从hash无法反推出数据。</li><li>每个数据的hash值唯一</li><li>对数据做很小的修改，hash值会变的完全不同</li><li>无法根据特定的hash值，去寻找生成这个hash值的数据</li></ul><p>在区块链中hash被用来保证块的一致性，区块中包含有前一个区块的hash值，如果要修改一个区块，那么这个区块之后的所有区块都会被影响，因此使得篡改区块链上的数据所要付出的代价会变得非常大。</p><p>由于无法知道生成一个特定的hash值所需要的数据，所以如果要生成一个符合特定条件的hash值唯一的方法是计算，在bitcoin中有一个nonce值，这个值在生成区块的过程中可以被改变，由此来计算不同的hash，而根据对hash值的要求不同，计算难度也完全不同。</p><p>因此我们在区块的实现中添加一个nonce值，用来计算hash，添加一个TARGET，用来控制区块生成的难度。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TARGET_HEXS: <span class="type">usize</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 区块结构体</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">u128</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    prev_block_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">    nonce: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中TARGET是指生成的hash值的前TARGET位需要为0。</p><p>工作量证明即不停修改nonce值，计算出一个符合TARGET难度的hash值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_proof_of_work</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">validate</span>()? &#123;</span><br><span class="line">        <span class="keyword">self</span>.nonce += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_hash_data</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;data);</span><br><span class="line">    <span class="keyword">self</span>.hash = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">validate</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_hash_data</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec1</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    vec1.<span class="title function_ invoke__">resize</span>(TARGET_HEXS, <span class="string">&#x27;0&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(hash[<span class="number">0</span>..TARGET_HEXS] == <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(vec1)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下添加工作量证明之后的区块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Blockchain &#123;</span><br><span class="line">    blocks: [</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241352238,</span><br><span class="line">            data: <span class="string">&quot;创世区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;0000f1ee1053aeff7a7184ae34907e79a4ce439007b26cff9f22e7a41c4ac4b8&quot;</span>,</span><br><span class="line">            nonce: 34797,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241352358,</span><br><span class="line">            data: <span class="string">&quot;手动添加一个区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;0000f1ee1053aeff7a7184ae34907e79a4ce439007b26cff9f22e7a41c4ac4b8&quot;</span>,        </span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;0000946eae88f47da86be7d067853e5d4cdc0bef6223e689112c6217f4f8cd29&quot;</span>,</span><br><span class="line">            nonce: 118886,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241353153,</span><br><span class="line">            data: <span class="string">&quot;工作996真的太烦了&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;0000946eae88f47da86be7d067853e5d4cdc0bef6223e689112c6217f4f8cd29&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;00002a7035984cf78cde09c3d67669c6e4edb055a17d3a195470910c2bb3fd71&quot;</span>,</span><br><span class="line">            nonce: 34257,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到hash值的前TARGET位为0。</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年度总结</title>
      <link href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2023年算是我工作的第一年，毕竟我在2023年年初才转正，工作之后才发现时间过的又快了一些，一年中发生了很多事情，我需要花时间来梳理一下，总结下今年。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>首先说下工作上的吧，毕竟已经是一个彻彻底底的打工人了，在华为工作的这一年算是学到了一些东西，但不是很多，在年初的时候我从防火墙的策略特性更换到了防火墙的PKI特性，最开始还有点不熟悉，但是经过大概半个月的了解我逐渐了解了PKI特性，上手之后还算轻松，而且PKI特性相对比较稳定，平时没有什么比较繁忙的事务，在PKI特性里也学到了很多，了解了加密，证书等等。在国庆之后，由于一些原因我换岗到了AR，在AR这边负责转发性能的测试，AR的事务看起来没有防火墙那边紧急，更重要的是AR团队在别的城市，不能和他们面对面交流让我有点不太适应。但总体还好，只是转发性能的脚本之前的人写的很烂，很多公用的操作全部写在方法里，没能提取出来，看这些脚本真的很心累。今年也经历了第一次涨薪，涨了500，说实话真不算多，但我也不能说什么，可能我只值这500。  </p><p>总体看起来我工作方面就是不温不火，没什么亮点，唯一让人开心的是绩效合格了，能拿到个年终奖。明年的工作暂时还没什么计划，不过我想换一份工作了，希望能换到一份rust开发的工作。不过说起来现在的rust开发是真的少（也不知道是不是我找的方式不对），基本大部分都和区块链相关，要么和web3相关，可惜这两者我都不太了解。不过国内很多大厂也在开始使用rust了，或许明年岗位会多一些？判断以后的形式我并不擅长，感觉我也没有什么远见。总之就是等机会吧，自己学习下，有机会的时候希望能把握住。  </p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>上班之后学习的时间大大减少了，不过还是能抽出一些时间来看看的。今年的学习情况也是一言难尽。  </p><p>在前半年的时候，我还每天回家会抽出0.5-1小时来看《深入理解计算机系统》，但是在6月份新冠阳了之后，感觉身体有些不舒服就没在看了，以为只是停一段时间，结果一直到年尾了也没再看过，真的不能懒惰。养成一个好习惯需要几个月时间，但忘掉一个好习惯却只需要几天。</p><p>今年在公司还关注到了rust的社区，学习了rust，感觉rust真的是一门很好的语言，我很喜欢。只是学习曲线比较陡峭，而且由于工作原因我也只能断断续续的学，学习效率有点低。不过经过一年时间，我也算是入门了吧（毕竟掌握了基本语法，能写出一些东西，学会了如何在文档中查找自己需要的东西）。只是到了rust异步那块，实在有点难啃，而且暂时没找到好的适合学习的项目（大部分好的项目基本都体量很大，拿来学习的话可能并不是一个好的选择），所以异步这块基本算是只写过书上的例子，还没有自己实际写过东西。和异步一样的还有unsafe rust，这块我完全没有用到，理解也很浅。但是感觉还好，毕竟safe rust我都还没完全掌握，等之后总有机会到unsafe领域的。  </p><p>由于受到rust的影响，今年还学习了区块链。区块链学习主要是看了肖臻老师的公开课，老师讲了比特币和以太坊，这是两个非常经典的基于区块链技术。区块链的思想真的很棒，实现了去中心化，可以去掉传统的第三方，直接的进行点对点的服务。而且以太坊中也有了更多的扩展，出现了智能合约。而且肖臻老师讲课真的是苏格拉底式的讲课，老师说的那句 <strong>知识改变命运，但一知半解的知识并不能让你过的更好。</strong> 让我深有感触。学习中还是要把知识理解透彻，如果只是一知半解，就像一个定时炸弹，你不知道它什么时候会爆炸，但它总有爆炸的一天。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>工作之后不仅学习时间变少了，生活时间也同样减少。每天下班基本到家就晚上9点多了，洗一洗就到了晚上10点多了，想做点自己的事情都完全没有时间。最开始每天晚上还能锻炼一下，做几组俯卧撑。也是在第一次阳了之后就没在做了。说起来6月份阳的那次也是真的很难受，发烧了1天半时间，最高烧到了38.9度，当时躺在床上动也动不了，不想再次体验了。不过比较幸运的是，12月份我的朋友们基本都甲流了，而我恰好逃过一劫，甲流没来找我，哈哈。平时生活也平平淡淡，节假日基本在家打游戏，偶尔出去和朋友一起玩，部门也没怎么组织团建，只组织了一次，还是大部门一起的，我们组单独的根本没组织过（最惨的是到最后我们团建的钱没怎么花过，然后年底被收走了，感觉亏损一个亿啊！！！）。然后今年12月体检，体检结果还好，各个内脏都好好的，没什么毛病，算是一个好消息。没东西了，上班之后基本没什么生活。彻彻底底的打工人（牛马）。</p><h2 id="未来一年"><a href="#未来一年" class="headerlink" title="未来一年"></a>未来一年</h2><p>新的一年希望能够变得越来越好，能养成几个好习惯。身体健康，工作顺利（感觉不会），希望家人也能健健康康。妖魔鬼怪快离开！妖魔鬼怪快离开！妖魔鬼怪快离开！<br>新的一年定几个小目标（能完成60%就可以了）：</p><ul><li>每周能去2-3次健身房锻炼身体。</li><li>继续学习rust，巩固基础，学习异步和unsafe，并且能自己写几个相关的项目demo，加深理解。</li><li>每两周去看个电影。</li><li>坚持写博客，把自己的所见所闻记录下来，把自己的学习感悟记录下来。</li><li>希望能换一份工作，想从事rust开发或者区块链开发（希望面试官们捞捞我）。</li><li>坚持读书，一年能读2本书（目前想读《计算机科学中的数学》，另一本暂时没定，毕竟也不知道这本能不能读完）</li></ul><p>这就是我新一年想做的事情，希望能坚持下来，新的一年加油。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
