<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库实现五执行器</title>
      <link href="/2024/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%94%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
      <url>/2024/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%94%E6%89%A7%E8%A1%8C%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器是负责执行 SQL 的组件，主要是对执行计划中的节点进行执行。然后返回正确的结果给用户。执行器在执行的过程中还会与存储引擎进行交互。这里先定义执行器，之后完善存储引擎之后，执行器才能正常工作。</p><h2 id="执行器定义"><a href="#执行器定义" class="headerlink" title="执行器定义"></a>执行器定义</h2><p>这里我们将执行器定义为一个 trait ，不同的执行节点对应的不同的执行器的实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;ResultSet&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 ResultSet 是执行返回的结果。不同的 SQL 类型返回结果不相同。我们定义为枚举类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">ResultSet</span> &#123;</span><br><span class="line">    CreateTable &#123;</span><br><span class="line">        table_name: <span class="type">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建表成功后返回表名。</p><p>然后实现具体的创建表的执行器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateTable</span> &#123;</span><br><span class="line">    schema: Table,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Executor</span> <span class="keyword">for</span> <span class="title class_">CreateTable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">execute</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;ResultSet&gt; &#123;</span><br><span class="line">        todo!()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里具体的执行需要去调用存储引擎的接口，我们先留空。</p><p>这样一个简单的存储引擎就定义好了。之后等我们完成了存储引擎相关的接口，就可以从这个执行器去调用存储引擎的接口执行相应的 SQL 了。</p>]]></content>
      
      
      <categories>
          
          <category> rust，数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库实现四执行计划</title>
      <link href="/2024/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%9B%9B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2024/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%9B%9B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>从语法分析阶段结束后我们拿到了抽象语法树，之后这个抽象语法树需要交给执行计划，通过执行计划去生成对应的物理计划。</p><p>首先，我们可以定义一个执行计划的节点 Node，这个节点对应了不同的语句生成的抽象语法树，例如，创建表，查询表，插入数据等。然后我们定义一个执行计划 Plan，这个执行计划内部是执行计划节点。</p><h2 id="执行节点定义"><a href="#执行节点定义" class="headerlink" title="执行节点定义"></a>执行节点定义</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    CreateTable &#123;</span><br><span class="line">        schema: Table,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望执行节点能够和抽象语法树相对应，这里使用枚举，在定义时可以和抽象语法树的定义相对应。</p><p>在上一节实现的创建表的抽象语法树中主要包含了表名和列信息，这里我们定义一个 Table 结构体，来保存表信息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> columns: <span class="type">Vec</span>&lt;Column&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Column</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> datatype: DataType,</span><br><span class="line">    <span class="keyword">pub</span> nullable: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> default: <span class="type">Option</span>&lt;Value&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的字段与我们抽象语法树里的内容对应。</p><h2 id="执行计划-1"><a href="#执行计划-1" class="headerlink" title="执行计划"></a>执行计划</h2><p>执行计划当中包含了执行节点：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Plan</span>(<span class="keyword">pub</span> Node);</span><br></pre></td></tr></table></figure><p>执行计划通过不同的执行节点，来生成相应的物理计划。</p><p>为执行计划提供一个 build 方法，传入参数使用解析生成的抽象语法树，生成一个执行计划。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Plan</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(stm: Statement) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Planner::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">build</span>(stm)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对抽象语法树的解析工作由 Planner 来完成。</p><p>对 Planner 的定义:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Planner</span>;</span><br></pre></td></tr></table></figure><p>由于 Planner 无需保存任何信息，只需要将传入的抽象语法树解析生成对应的 Plan 即可，因此在定义时无需任何内部元素。</p><p>为 Planner 实现解析逻辑：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Planner</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, stm: Statement) <span class="punctuation">-&gt;</span> Plan &#123;</span><br><span class="line">        <span class="title function_ invoke__">Plan</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">build_statment</span>(stm))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_statment</span>(&amp;<span class="keyword">self</span>, stm: Statement) <span class="punctuation">-&gt;</span> Node &#123;</span><br><span class="line">        <span class="keyword">match</span> stm &#123;</span><br><span class="line">            Statement::CreateTable &#123; name, columns &#125; =&gt; &#123;</span><br><span class="line">                Node::CreateTable &#123; schema: Table&#123;</span><br><span class="line">                    name,</span><br><span class="line">                    columns: columns.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(|c| &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">nullable</span> = c.nullable.<span class="title function_ invoke__">unwrap_or</span>(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">default</span> = <span class="keyword">match</span> c.default &#123;</span><br><span class="line">                            <span class="title function_ invoke__">Some</span>(expr) =&gt; &#123;</span><br><span class="line">                                <span class="title function_ invoke__">Some</span>(Value::<span class="title function_ invoke__">from_expression</span>(expr))</span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="literal">None</span> <span class="keyword">if</span> nullable =&gt; <span class="title function_ invoke__">Some</span>(Value::Null),</span><br><span class="line">                            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">                        &#125;;</span><br><span class="line">                        Column &#123;</span><br><span class="line">                            name: c.name,</span><br><span class="line">                            datatype: c.datatype,</span><br><span class="line">                            nullable,</span><br><span class="line">                            default,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).<span class="title function_ invoke__">collect</span>(),</span><br><span class="line">                &#125; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过内部的 build_statment 方法解析抽象语法树，生成执行节点，在通过 build 方法组装成一个 Plan。</p><p>由于执行节点出的 Column 与解析阶段的 Column 是不相同的，因此需要对抽象语法树生成的 columns，进行相应的修改。</p><p>至此我们通过解析抽象语法树，生成了对应的执行节点，并生成了对应的执行计划，下一节则会通过执行器，来执行生成的执行计划，最终通过底层的执行引擎，执行相关的操作。</p>]]></content>
      
      
      <categories>
          
          <category> rust，数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库实现三语法分析</title>
      <link href="/2024/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>在此之前我们已经实现了词法分析，将每个词都转换为了对应的 TOKEN ，现在我们的工作就需要将这些 TOKEN 通过语法分析来连接成语句，并输出相应的语法树。</p><h2 id="定义抽象语法树"><a href="#定义抽象语法树" class="headerlink" title="定义抽象语法树"></a>定义抽象语法树</h2><p>这里我们以 CreateTable 为例，使用枚举来定义出抽象语法树。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CREATE TABLE table_name (</span></span><br><span class="line"><span class="comment">//     [ column_name data_type [ column_constraint [...] ] ]</span></span><br><span class="line"><span class="comment">//     [, ... ]</span></span><br><span class="line"><span class="comment">//    );</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Statement</span>&#123;</span><br><span class="line">    CreateTable &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        columns: <span class="type">Vec</span>&lt;Column&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在创建表的过程中，我们需要拿到的数据有表名，以及列的信息。</p><p>列同样也需要存储一些信息，比如列名，列是否可以为空，列的类型，是否有默认值等。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Column</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> datatype: DataType,</span><br><span class="line">    <span class="keyword">pub</span> nullable: <span class="type">Option</span>&lt;<span class="type">bool</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> default: <span class="type">Option</span>&lt;Expression&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建表的过程中，可能指定默认值，而有些默认值会指定为表达式的形式，我们需要对表达式进行处理，这里我们只简单的实现一些常量的表达式处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Consts</span>(Consts),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Consts</span> &#123;</span><br><span class="line">    Null,</span><br><span class="line">    <span class="title function_ invoke__">Boolean</span>(<span class="type">bool</span>),</span><br><span class="line">    <span class="title function_ invoke__">Integer</span>(<span class="type">i64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">String</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="词法解析过程"><a href="#词法解析过程" class="headerlink" title="词法解析过程"></a>词法解析过程</h2><p>语法树相关的东西已经定义好了，接下来该进行语法分析，来输出一个抽象语法树了。</p><p>首先我们需要一个语法解析器，这个解析器要能拿到词法分析的结果，并去迭代每一个 TOKEN 。这里我们使用一个词法解析器来构造一个语法解析器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Parser</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    lexer: Peekable&lt;Lexer&lt;<span class="symbol">&#x27;a</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就拿到了一个词法解析器的迭代器。之前我们在实现词法解析器的迭代器时，内部的工作就是调用词法解析，并返回一个 TOKEN ，这里我们只需要对词法解析器迭代，即可获取 TOKEN 。</p><p>解析时我们需要根据我们的语法规则来进行，首先我们希望每个语句能够以分号来结束，并且我们当前只解析单一的语句，那么分号之后不希望再有其他字符。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">parse</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Statement&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stmt</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">parse_statement</span>()?;</span><br><span class="line">    <span class="comment">// 希望以分号结尾</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">next_expect</span>(Token::Semicolon)?;</span><br><span class="line">    <span class="comment">// 分号之后不再有内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(token) = <span class="keyword">self</span>.<span class="title function_ invoke__">peek</span>()? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(<span class="string">&quot;[Parser] Unexpected token &#123;&#125;&quot;</span>, token)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(stmt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 parse_statement() 方法是解析的开始，并返回一个抽象语法树，解析完成后检查是否以分号结尾。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_statement</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Statement&gt; &#123;</span><br><span class="line">    <span class="comment">// 查看第一个字符</span></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">peek</span>()? &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Create)) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">parse_ddl</span>(),</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析开始时我们首先查看语句第一个 TOKEN ，以确定这条语句的类型，这里我们只有 Create 语句，当匹配到第一个 TOKEN 之后，则进行相应语句的解析工作。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_ddl</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Statement&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next</span>()? &#123;</span><br><span class="line">        <span class="comment">// 期望是 Create 关键字</span></span><br><span class="line">        Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Create) =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next</span>()? &#123;</span><br><span class="line">            <span class="comment">// Create 关键字之后应该是 Table 关键字</span></span><br><span class="line">            Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Table) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">parse_ddl_create_table</span>(),</span><br><span class="line">            token =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(<span class="string">&quot;[Parser] Unexpected token &#123;&#125;&quot;</span>, token))),</span><br><span class="line">        &#125;,</span><br><span class="line">        token =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(<span class="string">&quot;[Parser] Unexpected token &#123;&#125;&quot;</span>, token))),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们定义的 Create 语句，在 Create 关键字后应该是 Table，同样的方式进行匹配，成功之后进行相应的处理，否则报错，语法错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_ddl_create_table</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Statement&gt; &#123;</span><br><span class="line">    <span class="comment">// 期望是表名</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">table_name</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">next_ident</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名之后是左括号</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">next_expect</span>(Token::OpenParen)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析列</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">columns</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        columns.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">parse_ddl_column</span>()?);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next_if_token</span>(Token::Comma).<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右括号</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">next_expect</span>(Token::CloseParen)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Statement::CreateTable &#123; </span><br><span class="line">        name: table_name, </span><br><span class="line">        columns: columns </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的语法符合，那么我们接下来拿到的就应该是表名，列信息，列信息我们在括号内进行，因此需要匹配两个括号，中间通过循环来解析列。我们定义的每一列信息中间以逗号分隔，当我们解析了一个列信息时，查看下一个字符是否为逗号，如果是，那么还有下一个列，否则列解析完成，跳出循环。最后使用拿到的表名和列信息来构造我们的抽象语法树。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_ddl_column</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Column&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">column</span> = Column&#123;</span><br><span class="line">        name: <span class="keyword">self</span>.<span class="title function_ invoke__">next_ident</span>()?,</span><br><span class="line">        datatype: <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next</span>()? &#123;</span><br><span class="line">            Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Bool) | Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Boolean) =&gt; DataType::Boolean,</span><br><span class="line">            Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Int) | Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Integer) =&gt; DataType::Integer,</span><br><span class="line">            Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Float) | Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Double) =&gt; DataType::Float,</span><br><span class="line">            Token::<span class="title function_ invoke__">Keyword</span>(Keyword::<span class="type">String</span>) | Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Text) | Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Varchar) =&gt; DataType::<span class="type">String</span>,</span><br><span class="line">            token =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(<span class="string">&quot;[Parser] Unexpected token &#123;&#125;&quot;</span>, token))),</span><br><span class="line">        &#125;,</span><br><span class="line">        nullable: <span class="literal">None</span>,</span><br><span class="line">        default: <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 判断下一个是否是关键字</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(Token::<span class="title function_ invoke__">Keyword</span>(keyword)) = <span class="keyword">self</span>.<span class="title function_ invoke__">next_if_keyword</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> keyword &#123;</span><br><span class="line">            Keyword::Null =&gt; column.nullable = <span class="title function_ invoke__">Some</span>(<span class="literal">true</span>),</span><br><span class="line">            Keyword::Not =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">next_expect</span>(Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Null))?;</span><br><span class="line">                column.nullable = <span class="title function_ invoke__">Some</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            Keyword::<span class="built_in">Default</span> =&gt; column.default = <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">parse_expression</span>()?),</span><br><span class="line">            k =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(<span class="string">&quot;[Parser] Unexpected keyword &#123;&#125;&quot;</span>, k))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(column)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列的解析，我们首先拿到的是列名，列名之后跟着类型，这两个是固定的，之后则可能出现多种情况，指定了是否非空，是否指定了默认值等，因此需要我们进行匹配，分别作出判断，如果出现了其他的关键字，那么我们需要进行报错，语法错误。最后将列信息返回。</p><p>最后则是对默认值的解析工作了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_expression</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Expression&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">next</span>()? &#123;</span><br><span class="line">        Token::<span class="title function_ invoke__">Number</span>(n) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> n.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">all</span>(|c| c.<span class="title function_ invoke__">is_ascii_digit</span>()) &#123;</span><br><span class="line">                ast::Consts::<span class="title function_ invoke__">Integer</span>(n.<span class="title function_ invoke__">parse</span>()?).<span class="title function_ invoke__">into</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ast::Consts::<span class="title function_ invoke__">Float</span>(n.<span class="title function_ invoke__">parse</span>()?).<span class="title function_ invoke__">into</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Token::<span class="title function_ invoke__">String</span>(s) =&gt; ast::Consts::<span class="title function_ invoke__">String</span>(s).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        Token::<span class="title function_ invoke__">Keyword</span>(Keyword::True) =&gt; ast::Consts::<span class="title function_ invoke__">Boolean</span>(<span class="literal">true</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        Token::<span class="title function_ invoke__">Keyword</span>(Keyword::False) =&gt; ast::Consts::<span class="title function_ invoke__">Boolean</span>(<span class="literal">false</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        Token::<span class="title function_ invoke__">Keyword</span>(Keyword::Null) =&gt; ast::Consts::Null.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        t =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(</span><br><span class="line">                <span class="string">&quot;[Parser] Unexpected expression token &#123;&#125;&quot;</span>,</span><br><span class="line">                t</span><br><span class="line">            )))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们的表达是只支持了几种常量类型，因此直接使用对应的模式匹配即可。</p><p>至此我们完成了 Create 语句的解析工作，并生成了抽象语法树。</p>]]></content>
      
      
      <categories>
          
          <category> rust，数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库实现二词法分析</title>
      <link href="/2024/08/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>词法分析需要将用户传入的文本命令解析成对应的 TOKEN，因此需要识别每次词并实现其对应的 TOKEN。</p><p>例如：</p><p>用户传入的 SQL 语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from a;</span><br></pre></td></tr></table></figure><p>对这一句命令进行分析，我们需要识别的字符包括 <code>select</code>, <code>*</code>,<code>from</code>,<code>a</code>,<code>;</code> 这五个。其中 <code>select</code>,<code>from</code>对应为关键字，而<code>*</code>和<code>;</code>则对应为特殊符号，有相应的含义，<code>a</code>这里表示表名，我们可以将其定义为字符串的 TOKEN。</p><p>同样关键字 TOKEN 还应该包括<code>create</code>,<code>insert</code>,这类操作相关的，以及<code>int</code>,<code>bool</code>这类表示类型的，以及<code>true</code>,<code>false</code>这种布尔值的等等。特殊字符还包括了<code>(</code>,<code>)</code>,<code>+</code>等这些，在进行词法分析时我们都需要将其识别，并输出对应的 TOKEN。</p><p>而且在识别一整个命令时，我们也需要将其中的空白字符，回车，换行进行相应的处理，最直接的是跳过。</p><h2 id="TOKEN-定义"><a href="#TOKEN-定义" class="headerlink" title="TOKEN 定义"></a>TOKEN 定义</h2><p>TOKEN 的定义我们可以使用枚举类型来实现，当我们分析每个词是，应该对应为其中的一种。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="comment">// 关键字</span></span><br><span class="line">    <span class="title function_ invoke__">Keyword</span>(Keyword),</span><br><span class="line">    <span class="comment">// 其他类型的字符串Token，比如表名、列名</span></span><br><span class="line">    <span class="title function_ invoke__">Ident</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="comment">// 字符串类型的数据</span></span><br><span class="line">    <span class="title function_ invoke__">String</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="comment">// 数值类型，比如整数和浮点数</span></span><br><span class="line">    <span class="title function_ invoke__">Number</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="comment">// 左括号 (</span></span><br><span class="line">    OpenParen,</span><br><span class="line">    <span class="comment">// 右括号 )</span></span><br><span class="line">    CloseParen,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中字符串类型数据，数字类型数据，标识符我们在内部都使用了字符串来保存，关键字则需要自定义一个结构体来表示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Keyword</span> &#123;</span><br><span class="line">    Create,</span><br><span class="line">    Table,</span><br><span class="line">    Int,</span><br><span class="line">    Integer,</span><br><span class="line">    Boolean,</span><br><span class="line">    Bool,</span><br><span class="line">    Not,</span><br><span class="line">    Null,</span><br><span class="line">    Primary,</span><br><span class="line">    Key,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字我们同样使用枚举类型来实现，每一个枚举值对应了不同的关键字。</p><h2 id="词法分析器实现"><a href="#词法分析器实现" class="headerlink" title="词法分析器实现"></a>词法分析器实现</h2><p>接下来是我们的词法分析器，我们的词法分析器需要接受用户传入的命令字符，并对其进行迭代，识别每一个字符，我们内部使用 Peekable 结构体来实现，Peekable 由迭代器调用 peekable() 方法来创建，主要使用其中的 peek() 方法，此方法可以在不推进迭代器的条件下返回当前值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Lexer</span>&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">    iter: Peekable&lt;Chars&lt;<span class="symbol">&#x27;a</span>&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并为解析器实现一个创建的方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(sql_text: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span> &#123; </span><br><span class="line">        iter: sql_text.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">peekable</span>() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过输入的字符串创建迭代器，并调用 peekable() 方法来创建一个解析器。</p><p>解析器创建之后我们需要将内部的迭代器进行一些操作，以收集 TOKEN ，举个例子，我们将迭代器进行推进，如果遇到了 <code>&#39;</code> 那么后面则是一个字符串，并且必须有对应的 <code>&#39;</code> 闭合，而我们需要的则是引号中的内容，如果遇到了字符开头，那么这可能是一个关键字，或者是一个标识符，我们需要进行识别，如果遇到了数字，这下一个 TOKEN 对应了 int, 或者 float，在不断推进直到识别到末尾的<code>;</code>我们知道一个完整的语句中的词被我们全部识别了。</p><p>因此我们需要为解析器实现一个识别的 scan() 方法，此方法不断推进内部的 iter。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描拿到下一个 token</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">scan</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;Token&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 首先清除 token 前空白字符</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">erase_whitespace</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.iter.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;\&#x27;&#x27;</span>) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">scan_string</span>(),   <span class="comment">// 如果遇到引号则进行字符串的识别</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(c) <span class="keyword">if</span> c.<span class="title function_ invoke__">is_ascii_digit</span>() =&gt; <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">scan_num</span>()),  <span class="comment">// 如果遇到数字则进行数字类型的识别</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(c) <span class="keyword">if</span> c.<span class="title function_ invoke__">is_alphabetic</span>() =&gt; <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">scan_ident</span>()),  <span class="comment">// 如果遇到字符开头我们则识别为标识符</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">scan_symbol</span>()),  <span class="comment">// 其他相关的运算符或者括号之类同一识别为符号</span></span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里处理完内部之后，我们还需要为解析器实现一个迭代器，这个迭代器则负责调用解析器自身的 scan() 方法，返回识别出的 TOKEN。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义迭代器，通过调用 scan 来扫描每个 token</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> <span class="title class_">Lexer</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">Result</span>&lt;Token&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">scan</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(token)) =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Ok</span>(token)),</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>) =&gt; <span class="keyword">self</span></span><br><span class="line">            .iter</span><br><span class="line">            .<span class="title function_ invoke__">peek</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|c| <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">Parse</span>(<span class="built_in">format!</span>(<span class="string">&quot;[Lexer] Unexpeted character &#123;&#125;&quot;</span>, c)))),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Err</span>(err)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属于解析器的迭代器每次向后推进都会返回一个相应的 TOKEN ，或者在识别到错误时返回错误。sacn() 函数在两种情况下会返回None，一种是完成了迭代，迭代器中以无内容，另一种是扫描到了当前情况下无法识别的字符，这时我们需要进行判断，如果是当前情况下输入了我们无法识别的字符，需要报错反馈。</p><p>此时我们的解析器就完成了相应的工作，将用户输入的文本命令解析为对应的 TOKEN 。</p>]]></content>
      
      
      <categories>
          
          <category> rust，数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库实现一架构分析</title>
      <link href="/2024/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL数据库架构概述"><a href="#SQL数据库架构概述" class="headerlink" title="SQL数据库架构概述"></a>SQL数据库架构概述</h2><p>数据库是用来将数据按照一定的结构进行存储，可以将数据进行持久化，并提供相应的接口，可以对数据进行查询，修改，删除，创建等操作。</p><p>关系数据库中使用了表，行，列的概念，行是一个对象的记录，列表示字段的类型，表由行和列组成，其中各个字段存在相应的关系，共同组成一个完整的记录。</p><p>数据库包括以下的几个关键组件：</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>SQL语句是一串文本，发送给服务端之后，服务端需要对这串文本进行解析，才能明白需要执行怎样的操作，<br>而解析器也分为了两部分，<strong>词法分析和语法分析</strong>，首先进行的是此法分析，分析每个词，将其解析为对应<br>的标识符 TOKEN ，并判断其合法性，之后语法分析拿到词法分析的结果，将 TOKEN 拼接为对应的语句，并判断<br>其语法的合法性，最后生成一个抽象语法树作为输出。</p><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>执行计划通常使用树的结构进行表示，其中主要包含了执行时的各种操作。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器会根据执行计划生成的路径，选择最优的执行方案。优化器在保证结果正确的前提下，会尽可能的降低<br>查询的成本。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行器负责执行执行计划的节点。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是数据库中的重要概念，其中包含了一组数据库操作，这些操作要么全部执行成功，要么全部执行失败，<br>事务具备原子性，一致性，隔离性和持久性(ACID)。事务管理的组件会控制事务的提交，回滚等。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>存储引擎是数据库内核中负责管理数据存储和检索的组件。它提供了将数据存储至磁盘，以及从磁盘读取数据<br>的接口。</p>]]></content>
      
      
      <categories>
          
          <category> rust，数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux驱动学习三</title>
      <link href="/2024/04/28/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%89/"/>
      <url>/2024/04/28/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h1><h2 id="字符设备驱动结构"><a href="#字符设备驱动结构" class="headerlink" title="字符设备驱动结构"></a>字符设备驱动结构</h2><p>在 linux 内核中使用 cdev 结构体描述一个<strong>字符设备</strong>，结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>             <span class="comment">/* 内嵌的kobject对象 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>            <span class="comment">/* 所属模块*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>     <span class="comment">/* 文件操作结构体*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="type">dev_t</span> dev;                       <span class="comment">/* 设备号*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 dev_t 成员定义了设备号，为32位，其中12位为主设备号，20位为次设备号，使用如下宏从 dev_t 获得主设备号和次设备号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="type">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure><p>而使用 MKDEV 宏则可以通过主设备号和次设备号生成 dev_t 成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MKDEV(<span class="type">int</span> major, <span class="type">int</span> minor)</span><br></pre></td></tr></table></figure><p>cdev 结构体的另一个重要成员 file_operations 定义了字符设备驱动提供给虚拟文件系统的接口函数。</p><p>linux 提供了一组函数用于操作 cdev 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_operations *)</span>;</span><br><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>;</span><br></pre></td></tr></table></figure><p>cdev_init 函数用于初始化 cdev 的成员，并与 file_operations 建立连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev); </span><br><span class="line">    INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">    cdev-&gt;ops = fops; <span class="comment">/* 将传入的文件操作结构体指针赋值给cdev的ops*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cdev_alloc 函数用于动态申请一个 cdev 内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> =</span> kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            INIT_LIST_HEAD(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">            kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cdev_add 函数和 cdev_del 函数分别向系统添加和删除一个cdev，完成字符设备的注册和注销。</p><h2 id="分配和释放设备号"><a href="#分配和释放设备号" class="headerlink" title="分配和释放设备号"></a>分配和释放设备号</h2><p>在调用 cdev_add 向系统注册字符设备之前，需要向系统申请设备号，通过调用 register_chrdev_region 或 alloc_chrdev_region 函数向系统申请设备号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>register_chrdev_region 函数用于已知起始设备的设备号的情况，alloc_chrdev_region 用于设备号未知，动态向系统申请未被占用的设备号，函数调用成功后，将设备号放入第一个 dev 参数中。</p><p>相应的在调用 cdev_del 函数将字符设备从系统中销毁之后，应调用 unregister_chrdev_region 释放原先申请的设备号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span>;</span><br></pre></td></tr></table></figure><h2 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h2><p>file_operations 结构体中的成员函数是字符设备驱动设计的主体内容。这些函数实际会在<strong>应用程序</strong>调用 linux 的 open , write , read , close 等函数时最终被内核调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">  <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">  <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">  <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">  <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">  <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">  <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">  <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *,  <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *,  <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">  <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,<span class="type">loff_t</span> len);</span><br><span class="line">  <span class="type">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>llseek 函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。</li><li>read 函数用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值。</li><li>write 函数向设备发送数据，成功时该函数返回写入的字节数。如果此函数未被实现，当用户进行 write 系统调用时，将得到-EINVAL返回值。</li><li>unlocked_ioctl 提供设备相关控制命令的实现（既不是读操作，也不是写操作）​，当调用成功时，返回给调用程序一个非负值。</li><li>mmap 函数将设备内存映射到进程的虚拟地址空间中，如果设备驱动未实现此函数，用户进行 mmap 系统调用时将获得-ENODEV返回值。</li><li>open 函数在用户调用 linux API 函数打开文件时被调用，如果驱动未实现这个函数，那么设备的打开操作永远成功。</li><li>poll 函数一般用于询问设备是否可被非阻塞地立即读写。</li></ul><h2 id="linux字符设备驱动的组成"><a href="#linux字符设备驱动的组成" class="headerlink" title="linux字符设备驱动的组成"></a>linux字符设备驱动的组成</h2><h3 id="字符设备驱动模块加载与卸载函数"><a href="#字符设备驱动模块加载与卸载函数" class="headerlink" title="字符设备驱动模块加载与卸载函数"></a>字符设备驱动模块加载与卸载函数</h3><p>在字符设备驱动模块加载函数中应该实现设备号申请与 cdev 注册，而在卸载函数中应实现设备号释放和 cdev 注销。<br>linux 在习惯上会定义一个设备结构体，包含设备设计的 cdev，私有数据以及锁等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设备结构体</span></span><br><span class="line"><span class="comment">struct xxx_dev_t &#123;</span></span><br><span class="line"><span class="comment">    struct cdev cdev;</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125; xxx_dev;</span></span><br><span class="line"><span class="comment">/* 设备驱动模块加载函数</span></span><br><span class="line"><span class="comment">static int _ _init xxx_init(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops);         /* 初始化cdev */</span></span><br><span class="line">  xxx_dev.cdev.owner = THIS_MODULE;</span><br><span class="line">  <span class="comment">/* 获取字符设备号*/</span></span><br><span class="line">  <span class="keyword">if</span> (xxx_major) &#123;</span><br><span class="line">      register_chrdev_region(xxx_dev_no, <span class="number">1</span>, DEV_NAME);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alloc_chrdev_region(&amp;xxx_dev_no, <span class="number">0</span>, <span class="number">1</span>, DEV_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, <span class="number">1</span>);  <span class="comment">/* 注册设备*/</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设备驱动模块卸载函数*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _ _exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  unregister_chrdev_region(xxx_dev_no, <span class="number">1</span>);      <span class="comment">/* 释放占用的设备号*/</span></span><br><span class="line">  cdev_del(&amp;xxx_dev.cdev);                      <span class="comment">/* 注销设备*/</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符设备驱动的file-operations结构体中的成员函数"><a href="#字符设备驱动的file-operations结构体中的成员函数" class="headerlink" title="字符设备驱动的file_operations结构体中的成员函数"></a>字符设备驱动的file_operations结构体中的成员函数</h3><p>file_operations 结构体中的函数是虚拟文件系统的接口，是用户空间对 linux 进行系统调用的最终落实。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读设备*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">xxx_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,<span class="type">loff_t</span>*f_pos)</span>   <span class="comment">// filp 是文件结构体指针， buf 是用户空间地址，count 是要读的字节数， f_pos 是读的位置相对于文件开头的偏移</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   copy_to_user(buf, ..., ...);   <span class="comment">// 由于用户空间不宜直接访问内核空间，因此使用这个函数完成用户空间到内核空间的复制</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 写设备*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">xxx_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,<span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   copy_from_user(..., buf, ...);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ioctl函数 */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">xxx_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd,<span class="type">unsigned</span> <span class="type">long</span> arg)</span>  <span class="comment">// </span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> XXX_CMD1:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> XXX_CMD2:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 不能支持的命令 */</span></span><br><span class="line">        <span class="keyword">return</span>  - ENOTTY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用于内核空间和用户空间复制的函数原型为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> _ _user *from, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> _ _user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure><p>其返回值为不能复制的字节数，如果复制成功则返回0。</p><p>如果需要复制的类型是简单类型则可以使用 put_user() 和 get_user()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val;                         <span class="comment">/* 内核空间整型变量</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">get_user(val, (int *) arg);      /* 用户→内核，arg是用户空间的地址 */</span></span><br><span class="line">...</span><br><span class="line">put_user(val, (<span class="type">int</span> *) arg);      <span class="comment">/* 内核→用户，arg是用户空间的地址 */</span></span><br></pre></td></tr></table></figure><p>内核空间在访问用户空间之前需要检查合法性。通过 access_ok(type,addr,size) 进行判断，以确认传入的缓存区确实属于用户空间。</p><p>检查合法性非常重要，在 copy_from_user() , copy_to_user() , get_user() , put_user() 函数中均进行了合法性检查。</p><p>在字符设备驱动中需要定义一个 file_operations 实例，将设备驱动函数赋值给 file_operations 成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read = xxx_read,</span><br><span class="line">    .write = xxx_write,</span><br><span class="line">    .unlocked_ioctl= xxx_ioctl,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 xxx_fops 在 cdev_init(&amp;xxx_dev.cdev,&amp;xxx_fops) 的语句中与 cdev 建立联系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字符设备通常会使用 cdev 结构体来表示，其中包含了设备号以及设备对应的文件操作结构体，其中文件操作结构体中的函数是我们要实现的重点，这个结构体通过 cdev_init() 函数来与 cdev 联系起来，linux 中则习惯于使用一个结构体来包含 cdev ，以及设备需要使用到的私有数据和锁等。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux驱动学习二</title>
      <link href="/2024/04/17/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
      <url>/2024/04/17/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="linux文件系统与设备文件"><a href="#linux文件系统与设备文件" class="headerlink" title="linux文件系统与设备文件"></a>linux文件系统与设备文件</h1><p>linux下一切皆文件，而驱动同样也需要和文件系统交互，这章来简单看下文件系统与设备文件。</p><h2 id="linux文件操作"><a href="#linux文件操作" class="headerlink" title="linux文件操作"></a>linux文件操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>其中参数 mode 指定新建文件的权限，与 umask 一起决定文件的最终权限。 而 umask 可以通过以下函数来改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">umask</span><span class="params">(<span class="type">int</span> newmask)</span>;</span><br></pre></td></tr></table></figure><p>该函数将 umask 设置为 newmask 返回旧的 umask。</p><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>其中 pathname 是要打开的文件名，包含路径，默认是当前目录下， flags 文件打开的标志。 如果标志选择创建文件，那么需要指定 mode 参数。</p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>其中 buf 为指向缓冲区的指针， length 为缓冲区大小(以字节为单位)。read 函数返回实际读到的字节数，write 返回实际写入的字节数。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">offset_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>lseek 将文件读写指针相对 whence 移动 offset 字节。成功时返回文件指针相对文件头的位置。whence 可选 <code>SEEK_SET</code> 相对文件头， <code>SEEK_CUR</code> 相对文件读写指针的当前位置， <code>SEEK_END</code> 相对文件末尾。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭文件只需要调用close函数，传入文件描述符即可。</p><h2 id="c库文件操作"><a href="#c库文件操作" class="headerlink" title="c库文件操作"></a>c库文件操作</h2><p>c 库文件操作独立于具体的操作系统平台。</p><h3 id="创建和打开"><a href="#创建和打开" class="headerlink" title="创建和打开"></a>创建和打开</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiLE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>用于打开指定文件，mode 为模式。 mode 模式中的 <code>b</code> 用于区分二进制文件和文本文件，在DOS,Windows中由区分，linux中无区分。</p><h3 id="读写-1"><a href="#读写-1" class="headerlink" title="读写"></a>读写</h3><p>C库函数支持以字符、字符串等为单位，支持按照某种格式进行文件的读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(fiLE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, fiLE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, fiLE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, fiLE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(fiLE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span> <span class="params">(fiLE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> n, fiLE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> n, fiLE *stream)</span>;</span><br></pre></td></tr></table></figure><p>c 库函数还提供了读写过程中的定位能力</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(fiLE *stream, <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(fiLE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(fiLE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><h3 id="关闭-1"><a href="#关闭-1" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span> <span class="params">(fiLE *stream)</span>;</span><br></pre></td></tr></table></figure><p>关闭依然为 close。</p><h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><h3 id="linux文件系统目录结构"><a href="#linux文件系统目录结构" class="headerlink" title="linux文件系统目录结构"></a>linux文件系统目录结构</h3><p>进入linux根目录下查看，包含以下目录：</p><ul><li>&#x2F;bin:包含基本命令，这个目录都是可执行文件。</li><li>&#x2F;sbin:包含系统命令，大多是管理命令，目录中的文件都是可执行的。</li><li>&#x2F;dev:设备文件存储目录，应用程序通过读写这些文件来访问设备。</li><li>&#x2F;etc:系统配置文件，一些服务器配置文件也在这里。</li><li>&#x2F;lib:系统库文件存放目录。</li><li>&#x2F;mnt:存放挂载存储设备的挂载目录。</li><li>&#x2F;opt:可选的，有些软件包会安装在这里。</li><li>&#x2F;proc:操作系统运行时，进程及内核信息被存放在这里。</li><li>&#x2F;tmp:用户运行程序时产生的临时文件，存放在这里。</li><li>&#x2F;usr:系统存放命令的目录，比如用户命令，用户库等。</li><li>&#x2F;var:经常变动的目录，里面有存放日志。</li><li>&#x2F;sys:Linux 2.6以后的内核所支持的sysfs文件系统被映射在此目录上。Linux设备驱动模型中的总线、驱动和设备都可以在sysfs文件系统中找到对应的节点。当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录。</li></ul><h3 id="linux文件系统与设备驱动"><a href="#linux文件系统与设备驱动" class="headerlink" title="linux文件系统与设备驱动"></a>linux文件系统与设备驱动</h3>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux驱动学习一</title>
      <link href="/2024/04/13/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
      <url>/2024/04/13/linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="linux内核编译"><a href="#linux内核编译" class="headerlink" title="linux内核编译"></a>linux内核编译</h1><blockquote><p>linux 内核配置</p></blockquote><p>比较推荐的是通过命令 <code>make menuconfig</code> 命令来进行配置，它不依赖于QT或GTK+，且非常直观，运行此命令配置之后，会生成一个 .config 配置文件，记录哪些部分被编译进内核，哪些部分被编译为模块，或者不编译。</p><p>linux 配置系统由三部分组成</p><ul><li>Makefile: 分布在Linux内核源代码中，定义Linux内核的编译规则。</li><li>Kconfig: 给用户提供配置选择的功能</li><li>配置工具: 包括配置命令解释器和配置用户界面</li></ul><p>首先来看 Kconfig 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config TTY_PRINTK</span><br><span class="line">       tristate <span class="string">&quot;TTY driver to output user messages via printk&quot;</span></span><br><span class="line">       depends on EXPERT &amp;&amp; TTY</span><br><span class="line">       default n</span><br><span class="line">       ---<span class="built_in">help</span>---</span><br><span class="line">        If you say Y here, the support <span class="keyword">for</span> writing user messages (i.e.</span><br><span class="line">        console messages) via printk is available.</span><br><span class="line">        The feature is useful to inline user messages with kernel</span><br><span class="line">        messages.</span><br><span class="line">        In order to use this feature, you should output user messages</span><br><span class="line">        to /dev/ttyprintk or redirect console to this TTY.</span><br><span class="line">        If unsure, say N.</span><br></pre></td></tr></table></figure><p>config 后跟的是配置项的符号， tristate 代表这个选项是一个三态选项，分别为 Y , N , M,其中 Y 表示编译进内核中， N 表示不进行编译， M 表示编译成内核模块，后面的字符则是在配置界面显示的内容。此处除了 tristate 还有 bool 等。 depends on 则表示这个模块依赖的模块有哪些，多个模块用 <code>&amp;&amp;</code> 来连接， default 表示默认值。 help 下跟的则是在配置中的帮助信息。</p><p>接下来看 Kbuild Makefile 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONfiG_ISDN) += isdn.o</span><br><span class="line">obj-$(CONfiG_ISDN_PPP_BSDCOMP) += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure><p>此处 obj-$(xxx) 其中的 xxx 即为配置项符号， 命名的方式是在 Kconfig 的符号前加了 CONFIG_ 字段， 当其值为 y 时，会根据后面的 .o 文件去找对应的 .c 或 .s 文件，编译进内核中，当为 n 时，则不进行编译， 为 m 时，则寻找对应的文件，编译为模块的形式， 这里对应了用户配置时的选择。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Makefile for the linux ext2-filesystem routines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">obj-$(CONfiG_EXT2_FS) += ext2.o</span><br><span class="line">ext2-y := balloc.o dir.o file.o fsync.o ialloc.o inode.o \</span><br><span class="line">       ioctl.o namei.o super.o symlink.o</span><br></pre></td></tr></table></figure><p>若一个模块由多个文件构成，则会去找对应的 .o 文件，最终链接生成最终的 .o 文件。此处若配置了 ext2.o ，则会去找 balloc.o  dir.o 等文件，最终生成 ext2.o 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONfiG_EXT2_FS) += ext2/</span><br></pre></td></tr></table></figure><p>目录层次，当配置为 y 或者 m 时，会迭代 ext2 目录。</p><h1 id="linux内核模块程序结构"><a href="#linux内核模块程序结构" class="headerlink" title="linux内核模块程序结构"></a>linux内核模块程序结构</h1><p>一般内核模块主要由以下几部分组成</p><ul><li>模块加载函数： 当使用 <code>insmod</code> 或 <code>modprobe</code> 命令加载模块时，模块加载函数被调用，完成初始化工作。</li><li>模块卸载函数： 当使用 <code>rmmod</code> 命令卸载模块时，会调用模块卸载函数，完成卸载功能。</li><li>模块许可声明： 声明内核模块的许可权限。(大多数情况下license为 GPL v2)</li><li>模块参数(可选)： 模块加载时可传递给模块的值。</li><li>模块导出符号(可选)： 内核模块导出的符号，若导出则其他模块可以使用本模块中的变量或函数。</li><li>模块作者等信息声明(可选)</li></ul><h2 id="模块加载函数"><a href="#模块加载函数" class="headerlink" title="模块加载函数"></a>模块加载函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _ _init <span class="title function_">initialization_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(initialization_function);</span><br></pre></td></tr></table></figure><p>模块加载函数一般以 <strong>__init</strong> 声明，而模块加载函数以 <strong>module_init(函数名)</strong> 的形式被指定，它返回整形值，模块初始化成功时返回0。失败则返回相应的错误码。</p><p>还可以使用 <strong>request_module(module_name)</strong> 来灵活加载其他内核模块。</p><h2 id="模块卸载函数"><a href="#模块卸载函数" class="headerlink" title="模块卸载函数"></a>模块卸载函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _ _exit <span class="title function_">cleanup_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/* 释放代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure><p>内核卸载函数一般以 <strong>__exit</strong> 声明，模块卸载函数在模块卸载时执行，不返回任何值，必须以 <strong>module_exit(函数名)</strong> 的形式来指定。若模块被编译进内核，则卸载函数会被省略。</p><h2 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *book_name = <span class="string">&quot;dissecting Linux Device Driver&quot;</span>;</span><br><span class="line">module_param(book_name, charp, S_IRUGO);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> book_num = <span class="number">4000</span>;</span><br><span class="line">module_param(book_num, <span class="type">int</span>, S_IRUGO);</span><br></pre></td></tr></table></figure><p>可以使用 <strong>modele_param(参数名,参数类型,参数读&#x2F;写权限)</strong> 为模块定义一个参数。 在加载模块时可以向模块传递参数 <code>insmod 模块名 参数名=参数值</code>。如果不传递，则使用定义的缺省值。 参数的类型可以为<br><strong>byte、short、ushort、int、uint、long、ulong、charp（字符指针）​、bool或invbool（布尔的反）</strong>。</p><p>此外模块还可以拥有参数数组，可以通过 <code>module_param_array(数组名,数组类型,数组长,参数读/写权限)</code> 来定义。</p><p>模块被加载后在 &#x2F;sys&#x2F;module 目录下会出现以模块名命名的目录，如果包含可读写的参数时，目录下还将包含 parameters 目录，其中包含参数名的一系列文件节点。</p><h2 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名);</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名);</span><br></pre></td></tr></table></figure><p>模块可以使用上述两个宏导出符号，其他模块使用时只需要提前声明即可。 <strong>EXPORT_SYMBOL_GPL</strong>导出的符号只适用于包含GPL许可权的模块。</p><h2 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCRIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure><p>上述宏分别用于声明模块的作者、描述、版本、设备表和别名。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux驱动学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust基础知识</title>
      <link href="/2024/03/20/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/03/20/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><p>在rust中通过 let 关键字来声明一个变量，并未变量绑定一个值，变量默认为不可变，即初始化之后无法对变量做出修改，可以不显示指定变量类型，编译器会自动推断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line">a = <span class="number">10</span>  <span class="comment">// 无法修改，会出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">5</span>;   <span class="comment">// 可以在变量名后跟 :变量类型  的方式来指定变量类型</span></span><br></pre></td></tr></table></figure><p>通过 mut 关键字使得变量具有可变性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">5</span>;  <span class="comment">// 通过 mut 关键字声明变量，则变量具有可变性</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 可以更改变量</span></span><br></pre></td></tr></table></figure><p>常量在rust中与不可变变量类似，但常量在声明时需要使用 const 关键字，并且在声明时必须指定类型，赋值只能为一个常量表达式，不能为一个需要在运行时得出的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NUM: <span class="type">i32</span> = <span class="number">100</span> * <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>rust中变量具有遮蔽行为，即在一个变量定义之后，可以使用相同的变量名来遮蔽之前的变量。遮蔽与可变性不同，遮蔽可以理解为重新创建了一个新的变量，类型可与之前不同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 在此之前变量 a 的值为5，之后值为 hello</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>rust中函数的入口时 main 函数，默认情况下 main 函数没有参数和返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数需要显示的指定类型，返回值类型则跟在小括号后。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="comment">// 需要一个 i32 类型的参数，返回一个 i32 的值。</span></span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句与表达式，语句不会返回值，表达式会返回值。表达式可以赋值给另一个变量，而语句不可以。同理表达式可以作为函数的返回值，比如上面函数返回 x</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;   <span class="comment">// 这是一条语句，没有返回值</span></span><br><span class="line">a   <span class="comment">// 这是一个表达式，会返回 a </span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>if 判断语句，直接在 if 后跟判断的条件即可，注意在 rust 中 if 是一个表达式，会产生值，可以赋值给另一个变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&gt;5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&lt;=5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回两个数中的较大值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">max</span> = <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// if 后同样可以接多个 else if</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">90</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">80</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">70</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop 循环语句，执行循环，直到代码指定跳出，否则一直循环下去，loop 同样属于语句，可以有返回值，返回值可通过 break 返回。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> a;    <span class="comment">// 这里 break 指定跳出循环，并返回值给变量 b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>while 条件循环，当条件为真时，执行循环，为假时跳出循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">100</span> &#123;</span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环，相比 while 循环，for 循环在遍历集合中的元素时更加方便。并且不会出现越界的行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a&#123;i&#125;=&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>所有权是rust特有的特性，同样也是核心功能之一，保证rust在没有gc的情况下还能够做到内存安全。</p><p>rust所有权有三个规则：</p><ul><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li><li>值在任一时刻只有一个所有者。</li><li>当所有者离开作用域，值将被丢弃。</li></ul><p>首先来看作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                               <span class="comment">// s 未进行声明，不可使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;            <span class="comment">// 声明变量 s 变量 s 有效，可使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;                               <span class="comment">// 离开作用域，变量 s 无效，值被丢弃</span></span><br></pre></td></tr></table></figure><p>接下来需要介绍一下栈内存和堆内存，在rust中，如果数据的大小是固定的且已知的，那么会被存放在栈内存中，否则将会被存放在堆内存，所有权更主要是管理堆上的内存空间。</p><p>以String类型为例：String字符串在创建是未知大小，所以会被分配到堆空间。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);      <span class="comment">// 在堆空间分配内存存放值</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);                    <span class="comment">// 在字符串值后追加内容</span></span><br><span class="line">&#125;                                           </span><br></pre></td></tr></table></figure><p>字符串的内容会被存储在堆空间中，在栈上会存放一个指向堆数据的指针，这个指针大小是固定的。</p><p>而对于大小确定的类型，则会分配在栈内存中，比如i32。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>:<span class="type">i32</span> = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于分配在栈上的数据，在移动时会发生 copy 行为，简单理解就是复制了一份同样的数据放在了栈中，原本的数据还存在，也就是说有两个可用的数据，每个数据分别属于各自的变量。这是因为栈上的数据 copy 速度很快，直接 copy 没有什么问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:<span class="type">i32</span> = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;     <span class="comment">// 此时发生了 copy 行为，栈中会存在两份数据，a 和 b 均可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于堆上的数据则不是这样，在移动时不会去复制堆上的数据(除非你使用 clone 去指定)，一般是再创建一个在栈上的指针，指向堆上的数据，那么现在就存在问题了，一份堆上的数据，有两个指针都指向了它，这和上面所说的值在任一时刻只有一个所有者违背，并且当离开作用域时，两个所有者都会对这个空间进行释放，这会出现问题，所以在 rust 中，当一个堆上的数据被移动时会发生 move 行为，即值移动到了新的所有者，旧的所有者不再有作用，如果访问会发生错误，这是在离开作用域时也不会被释放两次。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = s;   <span class="comment">//  此时 s 的值被移动到了 m 中，s 不在有效，无法使用，在离开作用域是 m 负责释放堆上对应的空间。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种数据传递方式就是克隆，如果使用 clone 方法，那么数据会被完整的 clone 出一份，传递给新的所有者，旧的数据依然属于原来的所有者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = s.<span class="title function_ invoke__">clone</span>()  <span class="comment">// 此时调用了clone函数，所以 s 值的所有权没有发生移动，s 依然可以使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数参数以及返回值中也同样要遵循所有权规则，按照参数的类型，以及存放的位置，会发生对应的 copy 或者 move 行为。</p><h2 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h2><p>引用，顾名思义，需要引用其他的值，同时不会拿走值的所有权。</p><p>rust 程序语言设计中的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// 此处创建了一个字符串变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);   <span class="comment">// 此处对变量进行了引用，使用 &amp; 符号，没有拿走值的所有权</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);  <span class="comment">// 因此在函数调用完成后，s1 变量的值依然存在未被丢弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;  <span class="comment">// 此处参数声明的 &amp; 符号即是引用符号</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出通过 &amp; 符号与一个值可以创建一个值所对应的引用，可以使用值的同时不转移所有权，引用使用后被丢弃，但是原本的值不收影响。这种引用的行为被称为借用。</p><p>这里只通过 &amp; 符号创建的引用是不可变引用，即不可以修改。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);  <span class="comment">// 尝试修改不可变引用会发生错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与之相对应的则是可变引用，通过 &amp;mut 来进行创建。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);  <span class="comment">// 这里创建了一个 s 的可变引用。注意，此处需要 s 本身也是可变的才可以。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123; <span class="comment">// 此处函数参数在进行声明时使用了可变引用</span></span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);  <span class="comment">// 此处可以通过这个可变引用来修改原本的值。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可变引用在同一时间只能存在一个，不可变引用可以同时存在多个，这主要是为了避免数据竞争。同时在不可变引用存在期间，不可以有可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;   <span class="comment">// 此处同时创建了两个可变引用，并且两个可变引用生命周期出现了重叠，这是不允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2); <span class="comment">// 两个引用在此同时使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面这种情况下，两个可变引用生命周期未发生重叠，属于合法的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在不可变引用存在期间，不允许创建可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里引用的生命周期结束，即指引用最后一次使用的地方，在此之后，这个引用被视为生命周期结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">    <span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时引用也有着限制，引用的生命周期不能比原本值的生命周期更长，这会出现悬垂引用的问题，出现这种情况是编译器一般会报错。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片允许你引用集合中的一段连续的元素，而切片同样也不会拿走所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure><p>可以看到切片的用法 <code>[start..end]</code> 通过指定起始坐标以及结束坐标来获取指定的切片，这里会包含 start 而不包含 end。</p><p>如果切片的起始位置是0，则0可以省略。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s[..<span class="number">5</span>];  <span class="comment">// 这两种写法获取的切片是相同的。</span></span><br></pre></td></tr></table></figure><p>同样，如果切片的结尾包含了集合的最后元素，那么 end 也是可以省略的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s[<span class="number">3</span>..];  <span class="comment">// 这两种写法获取的切片是相同的。</span></span><br></pre></td></tr></table></figure><p>同样通过切片的方式创建的值是不可变的。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体允许你将不同类型的元素组合在一起，并给每个元素赋予一个名字，以此来组成一个特殊的具有意义的值。而结构体在进行访问时可以直接通过元素名字来访问。</p><p>定义结构体需要使用 <code>struct</code> 关键字 + 结构体名字来定义，后面使用大括号将结构体元素包含。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;      <span class="comment">// 定义了结构体类型名字 User </span></span><br><span class="line">    active: <span class="type">bool</span>,    <span class="comment">//  结构体中的各个元素，以及元素对应的类型</span></span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结构体在进行使用时，需要实例化一个结构体，在实例化过程中需要为每个元素赋予对应类型的值，赋值可以使用 <code>元素名: 值</code> 的方式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;     <span class="comment">//  通过结构体类型名来创建一个结构体</span></span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),   <span class="comment">//  为结构体的每个元素赋值，顺序可以与定义顺序不同</span></span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">email</span> = user1.email   <span class="comment">// 使用结构体中的值可以使用 . 符号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果结构体是可变的，那么可以通过 <code>结构体变量名.元素名 = </code> 的方式改变结构体元素值。<strong>注意必须整个实例是可变的，rust 不支持只将某个元素标记为可变</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;   <span class="comment">//  实例可变</span></span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);  <span class="comment">// 给实例的元素修改值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在通过变量为结构体元素赋值时，如果变量名和结构体元素名相同，则可以简写为结构体元素名即可。<code>元素名: 变量名</code> -&gt; <code>元素名</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,     <span class="comment">// 变量名与元素名相同，简写即可</span></span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = <span class="title function_ invoke__">build_user</span>(</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过结构体实例来创建新结构体时，可以使用结构体更新语法来创建结构体，只需更新不同的元素的值即可，相同的元素值可以使用 <code>..实例名</code> 来省略。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),  <span class="comment">// 更新与 user1 不同的元素</span></span><br><span class="line">        ..user1  <span class="comment">// 相同元素可以省略</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结构体同样也会涉及到所有权问题，包括结构体中的元素，如果通过结构体 user1 来创建了 user2 ，那么 user1 将不能再使用，如果将结构体中的元素值赋予了其他变量，那么元素的所有权也将转移。</p><p>比较特殊的还有单元结构体，其中没有包含任何元素，如果仅仅想在结构体上实现某些 trait 而不需要携带数据时，可以使用单元结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链demo</title>
      <link href="/2024/02/10/%E5%8C%BA%E5%9D%97%E9%93%BEdemo/"/>
      <url>/2024/02/10/%E5%8C%BA%E5%9D%97%E9%93%BEdemo/</url>
      
        <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>区块链是一个公开的，不可篡改的分布式数据库，每个人都有一个完整的或部分的副本，区块链应用部署于每个节点上，必须通过大多数节点的认同，才可以向区块链中添加内容。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块链由一个一个区块构成，所有信息也全部存在于区块之中，区块还包含了额外的其他信息，包括版本信息，时间戳，前一个区块的哈希值，以及当前区块的哈希值。</p><p>而在这个demo中我们的区块里只需要包含一些简单信息，我们目前的区块仅仅包含了如下信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">u128</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    prev_block_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在bitcoin中区块存在区块头，区块头是一个独立的结构体，时间戳，hash这些在区块头中，而区块头和交易信息等构成了区块。为了简便起见，我将信息和时间戳，hash等全部放入区块结构体中。</p><p>其中时间戳是记录当前区块的时间，内容则是每个节点需要向区块中记录的信息，前一个hash值，记录上一个区块的hash，当前hash则计算前三个字段的hash。</p><p>hash计算在bitcoin中是非常重要的一部分，正是因为hash计算才能保证bitcoin的安全，hash具有不可逆性，抗碰撞性，很难找到两个不同的数据具有同样的hash值，也无法通过hash值来反推数据，所以如果想要找到符合条件的hash值，那么唯一的方法就是不断计算，直到尝试出正确的解，正是由于这种特性，使得hash可以用来作为工作量的评估标准。在工作量证明部分我们会再看。</p><p>计算hash设置区块内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">set_hash</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 计算时间戳</span></span><br><span class="line">    <span class="keyword">self</span>.timestamp = SystemTime::<span class="title function_ invoke__">now</span>()</span><br><span class="line">                        .<span class="title function_ invoke__">duration_since</span>(SystemTime::UNIX_EPOCH)?</span><br><span class="line">                        .<span class="title function_ invoke__">as_millis</span>();</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = (<span class="keyword">self</span>.timestamp,<span class="keyword">self</span>.data.<span class="title function_ invoke__">clone</span>(),<span class="keyword">self</span>.prev_block_hash.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = <span class="title function_ invoke__">serialize</span>(&amp;content)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;bytes);</span><br><span class="line">    <span class="keyword">self</span>.hash = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个新区块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_block</span>(data: <span class="type">String</span>,prev_block_hash: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Block&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">block</span> = Block&#123;</span><br><span class="line">        timestamp: <span class="number">0</span>,</span><br><span class="line">        data,</span><br><span class="line">        prev_block_hash,</span><br><span class="line">        hash: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = block.<span class="title function_ invoke__">set_hash</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>有了区块，就可以开始构建区块链了，区块链中后一个区块指向前一个区块，根据时间顺序不停向后拓展，我们可以方便的获取最新的区块。这里我们用一个集合来保存区块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Blockchain</span> &#123;</span><br><span class="line">    blocks: <span class="type">Vec</span>&lt;Block&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在区块链中，第一个出现的块被称为创世区块，也是整个链的起点，初始化一个区块链，在初始化的过程中，需要生成一个创世区块。<br>为区块添加生成创世区块方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_genesis_block</span>() <span class="punctuation">-&gt;</span> Block &#123;</span><br><span class="line">    Block::<span class="title function_ invoke__">new_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;创世区块&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">new</span>()).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个链：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Blockchain &#123;</span><br><span class="line">    Blockchain&#123;</span><br><span class="line">        blocks: <span class="built_in">vec!</span>[Block::<span class="title function_ invoke__">new_genesis_block</span>()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向区块链上添加区块:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_block</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,data:<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">prev</span> = <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_block</span> = Block::<span class="title function_ invoke__">new_block</span>(data, prev.<span class="title function_ invoke__">get_hash</span>())?;</span><br><span class="line">    <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">push</span>(new_block);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok基本的区块和区块链已经完成，来测试一下看结果如何。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bc</span> = Blockchain::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = bc.<span class="title function_ invoke__">add_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;手动添加一个区块&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = bc.<span class="title function_ invoke__">add_block</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;工作996真的太烦了&quot;</span>));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,bc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Blockchain &#123;</span><br><span class="line">    blocks: [</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;创世区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;4641856e7ada2e715ac99e8caa4410bcf98a6a36c38cb1729217ae617facc07d&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;手动添加一个区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;4641856e7ada2e715ac99e8caa4410bcf98a6a36c38cb1729217ae617facc07d&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;85f61860660b0c1b73c24a433d821db1951c3f554d535a5f60aaf2bb4d98b0f7&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1710040858947,</span><br><span class="line">            data: <span class="string">&quot;工作996真的太烦了&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;85f61860660b0c1b73c24a433d821db1951c3f554d535a5f60aaf2bb4d98b0f7&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;fc90e189dc162fd68edfce5376c32fd7347e19a36deee2d8da2c588356081516&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区块链雏形完成。</p><h1 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h1><p>工作量证明在区块链中是非常重要的一部分，同时也保证了区块链的安全性。就如同我们在生活中一样，需要通过努力工作，才能拿到相应的报酬，而在区块链中每个矿工通过进行一定量的工作，来挖出一个区块，并从区块中得到一定的奖励。这样的机制就叫做工作量证明。在bitcoin中区块的生成速度被控制在10分钟左右，而工作则是寻找符合条件的hash值，只有找到符合条件的hash值，那么这个区块才算是一个合法的区块，所以对于矿工而言，就需要不断计算hash值。</p><h2 id="hash计算"><a href="#hash计算" class="headerlink" title="hash计算"></a>hash计算</h2><p>通过hash函数可以计算给定数据的hash值，hash函数会输出一个固定长度的哈希值，hash具有几个特点：</p><ul><li>从数据可以计算出hash，而从hash无法反推出数据。</li><li>每个数据的hash值唯一</li><li>对数据做很小的修改，hash值会变的完全不同</li><li>无法根据特定的hash值，去寻找生成这个hash值的数据</li></ul><p>在区块链中hash被用来保证块的一致性，区块中包含有前一个区块的hash值，如果要修改一个区块，那么这个区块之后的所有区块都会被影响，因此使得篡改区块链上的数据所要付出的代价会变得非常大。</p><p>由于无法知道生成一个特定的hash值所需要的数据，所以如果要生成一个符合特定条件的hash值唯一的方法是计算，在bitcoin中有一个nonce值，这个值在生成区块的过程中可以被改变，由此来计算不同的hash，而根据对hash值的要求不同，计算难度也完全不同。</p><p>因此我们在区块的实现中添加一个nonce值，用来计算hash，添加一个TARGET，用来控制区块生成的难度。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TARGET_HEXS: <span class="type">usize</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 区块结构体</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">u128</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    prev_block_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">    nonce: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中TARGET是指生成的hash值的前TARGET位需要为0。</p><p>工作量证明即不停修改nonce值，计算出一个符合TARGET难度的hash值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_proof_of_work</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">validate</span>()? &#123;</span><br><span class="line">        <span class="keyword">self</span>.nonce += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_hash_data</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;data);</span><br><span class="line">    <span class="keyword">self</span>.hash = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">validate</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_hash_data</span>()?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hasher.<span class="title function_ invoke__">input</span>(&amp;data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">result_str</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec1</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    vec1.<span class="title function_ invoke__">resize</span>(TARGET_HEXS, <span class="string">&#x27;0&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(hash[<span class="number">0</span>..TARGET_HEXS] == <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(vec1)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下添加工作量证明之后的区块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Blockchain &#123;</span><br><span class="line">    blocks: [</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241352238,</span><br><span class="line">            data: <span class="string">&quot;创世区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;0000f1ee1053aeff7a7184ae34907e79a4ce439007b26cff9f22e7a41c4ac4b8&quot;</span>,</span><br><span class="line">            nonce: 34797,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241352358,</span><br><span class="line">            data: <span class="string">&quot;手动添加一个区块&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;0000f1ee1053aeff7a7184ae34907e79a4ce439007b26cff9f22e7a41c4ac4b8&quot;</span>,        </span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;0000946eae88f47da86be7d067853e5d4cdc0bef6223e689112c6217f4f8cd29&quot;</span>,</span><br><span class="line">            nonce: 118886,</span><br><span class="line">        &#125;,</span><br><span class="line">        Block &#123;</span><br><span class="line">            timestamp: 1711241353153,</span><br><span class="line">            data: <span class="string">&quot;工作996真的太烦了&quot;</span>,</span><br><span class="line">            prev_block_hash: <span class="string">&quot;0000946eae88f47da86be7d067853e5d4cdc0bef6223e689112c6217f4f8cd29&quot;</span>,</span><br><span class="line">            <span class="built_in">hash</span>: <span class="string">&quot;00002a7035984cf78cde09c3d67669c6e4edb055a17d3a195470910c2bb3fd71&quot;</span>,</span><br><span class="line">            nonce: 34257,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到hash值的前TARGET位为0。</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年度总结</title>
      <link href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2023年算是我工作的第一年，毕竟我在2023年年初才转正，工作之后才发现时间过的又快了一些，一年中发生了很多事情，我需要花时间来梳理一下，总结下今年。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>首先说下工作上的吧，毕竟已经是一个彻彻底底的打工人了，在华为工作的这一年算是学到了一些东西，但不是很多，在年初的时候我从防火墙的策略特性更换到了防火墙的PKI特性，最开始还有点不熟悉，但是经过大概半个月的了解我逐渐了解了PKI特性，上手之后还算轻松，而且PKI特性相对比较稳定，平时没有什么比较繁忙的事务，在PKI特性里也学到了很多，了解了加密，证书等等。在国庆之后，由于一些原因我换岗到了AR，在AR这边负责转发性能的测试，AR的事务看起来没有防火墙那边紧急，更重要的是AR团队在别的城市，不能和他们面对面交流让我有点不太适应。但总体还好，只是转发性能的脚本之前的人写的很烂，很多公用的操作全部写在方法里，没能提取出来，看这些脚本真的很心累。今年也经历了第一次涨薪，涨了500，说实话真不算多，但我也不能说什么，可能我只值这500。  </p><p>总体看起来我工作方面就是不温不火，没什么亮点，唯一让人开心的是绩效合格了，能拿到个年终奖。明年的工作暂时还没什么计划，不过我想换一份工作了，希望能换到一份rust开发的工作。不过说起来现在的rust开发是真的少（也不知道是不是我找的方式不对），基本大部分都和区块链相关，要么和web3相关，可惜这两者我都不太了解。不过国内很多大厂也在开始使用rust了，或许明年岗位会多一些？判断以后的形式我并不擅长，感觉我也没有什么远见。总之就是等机会吧，自己学习下，有机会的时候希望能把握住。  </p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>上班之后学习的时间大大减少了，不过还是能抽出一些时间来看看的。今年的学习情况也是一言难尽。  </p><p>在前半年的时候，我还每天回家会抽出0.5-1小时来看《深入理解计算机系统》，但是在6月份新冠阳了之后，感觉身体有些不舒服就没在看了，以为只是停一段时间，结果一直到年尾了也没再看过，真的不能懒惰。养成一个好习惯需要几个月时间，但忘掉一个好习惯却只需要几天。</p><p>今年在公司还关注到了rust的社区，学习了rust，感觉rust真的是一门很好的语言，我很喜欢。只是学习曲线比较陡峭，而且由于工作原因我也只能断断续续的学，学习效率有点低。不过经过一年时间，我也算是入门了吧（毕竟掌握了基本语法，能写出一些东西，学会了如何在文档中查找自己需要的东西）。只是到了rust异步那块，实在有点难啃，而且暂时没找到好的适合学习的项目（大部分好的项目基本都体量很大，拿来学习的话可能并不是一个好的选择），所以异步这块基本算是只写过书上的例子，还没有自己实际写过东西。和异步一样的还有unsafe rust，这块我完全没有用到，理解也很浅。但是感觉还好，毕竟safe rust我都还没完全掌握，等之后总有机会到unsafe领域的。  </p><p>由于受到rust的影响，今年还学习了区块链。区块链学习主要是看了肖臻老师的公开课，老师讲了比特币和以太坊，这是两个非常经典的基于区块链技术。区块链的思想真的很棒，实现了去中心化，可以去掉传统的第三方，直接的进行点对点的服务。而且以太坊中也有了更多的扩展，出现了智能合约。而且肖臻老师讲课真的是苏格拉底式的讲课，老师说的那句 <strong>知识改变命运，但一知半解的知识并不能让你过的更好。</strong> 让我深有感触。学习中还是要把知识理解透彻，如果只是一知半解，就像一个定时炸弹，你不知道它什么时候会爆炸，但它总有爆炸的一天。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>工作之后不仅学习时间变少了，生活时间也同样减少。每天下班基本到家就晚上9点多了，洗一洗就到了晚上10点多了，想做点自己的事情都完全没有时间。最开始每天晚上还能锻炼一下，做几组俯卧撑。也是在第一次阳了之后就没在做了。说起来6月份阳的那次也是真的很难受，发烧了1天半时间，最高烧到了38.9度，当时躺在床上动也动不了，不想再次体验了。不过比较幸运的是，12月份我的朋友们基本都甲流了，而我恰好逃过一劫，甲流没来找我，哈哈。平时生活也平平淡淡，节假日基本在家打游戏，偶尔出去和朋友一起玩，部门也没怎么组织团建，只组织了一次，还是大部门一起的，我们组单独的根本没组织过（最惨的是到最后我们团建的钱没怎么花过，然后年底被收走了，感觉亏损一个亿啊！！！）。然后今年12月体检，体检结果还好，各个内脏都好好的，没什么毛病，算是一个好消息。没东西了，上班之后基本没什么生活。彻彻底底的打工人（牛马）。</p><h2 id="未来一年"><a href="#未来一年" class="headerlink" title="未来一年"></a>未来一年</h2><p>新的一年希望能够变得越来越好，能养成几个好习惯。身体健康，工作顺利（感觉不会），希望家人也能健健康康。妖魔鬼怪快离开！妖魔鬼怪快离开！妖魔鬼怪快离开！<br>新的一年定几个小目标（能完成60%就可以了）：</p><ul><li>每周能去2-3次健身房锻炼身体。</li><li>继续学习rust，巩固基础，学习异步和unsafe，并且能自己写几个相关的项目demo，加深理解。</li><li>每两周去看个电影。</li><li>坚持写博客，把自己的所见所闻记录下来，把自己的学习感悟记录下来。</li><li>希望能换一份工作，想从事rust开发或者区块链开发（希望面试官们捞捞我）。</li><li>坚持读书，一年能读2本书（目前想读《计算机科学中的数学》，另一本暂时没定，毕竟也不知道这本能不能读完）</li></ul><p>这就是我新一年想做的事情，希望能坚持下来，新的一年加油。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
